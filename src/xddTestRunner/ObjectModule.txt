////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ МОДУЛЯ

// Прокси-объект для взаимодействия с внешним миром, 
// когда браузер тестов открывается извне, например,
// скриптом для Снегопата.
// 
Перем mMiddleMan;

Перем мИнформатор; // работа с таблицей методов в runtime
Перем мПытаемсяСоздатьИнформатор;

Перем мЗначенияСостоянияТестов Экспорт;
Перем мЗначенияТиповСтроки Экспорт;
Перем мЗначениеМодульИлиФорма Экспорт;
Перем РезультатыСравненияТаблиц Экспорт;

// Хранит количество загруженных тестовых случаев.
Перем мКоличествоТестовыхСлучаев Экспорт;

Перем мСоответствиеСтатусовДляTeamCity;

Перем СтатусыРезультатаТестирования Экспорт;
Перем кэшТестовыхОбработок;

Функция Версия() Экспорт
	Возврат "3.0.0.6";
КонецФункции

Функция ЗаголовокФормы() Экспорт
	Возврат СокрЛП(Метаданные().Синоним) + ", версия " + Версия() + " - Ctrl+Enter выполняет выделенные тесты";
КонецФункции

//{ МЕТОДЫ ДЛЯ ПРОВЕРКИ ЗНАЧЕНИЙ (assertions). 

Процедура Проверить(_Истина, ДопСообщениеОшибки = "") Экспорт
	Если Не _Истина Тогда
		СообщениеОшибки = "Переданный параметр ("+Формат(_Истина, "БЛ=ложь; БИ=истина")+") не является Истиной, а хотели, чтобы являлся." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьИстину(_Истина, ДопСообщениеОшибки = "") Экспорт
	Проверить(_Истина, ДопСообщениеОшибки);
КонецПроцедуры

Процедура ПроверитьЛожь(_Ложь, ДопСообщениеОшибки = "") Экспорт
	Если _Ложь Тогда
		СообщениеОшибки = "Переданный параметр ("+Формат(_Ложь, "БЛ=ложь; БИ=истина")+") не является Ложью, а хотели, чтобы являлся." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьДату(_Дата, _Период, ДопСообщениеОшибки = "") Экспорт
	Если _Дата < _Период.ДатаНачала или _Дата > _Период.ДатаОкончания Тогда
		представление = ПредставлениеПериода(_Период.ДатаНачала, _Период.ДатаОкончания, "ФП = Истина");
		СообщениеОшибки = "Переданный параметр ("+Формат(_Дата, "ДФ='dd.MM.yyyy HH:mm:ss'")+") не входит в период "+представление+", а хотели, чтобы являлся." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьРавенствоДатСТочностью2Секунды(_Дата, _Дата2, ДопСообщениеОшибки = "") Экспорт
	Если _Дата < _Дата2-2 или _Дата > _Дата2+2 Тогда
		СообщениеОшибки = "Переданная дата ("+Формат(_Дата, "ДФ='dd.MM.yyyy HH:mm:ss'")+") не равна дате ("+Формат(_Дата2, "ДФ='dd.MM.yyyy HH:mm:ss'")+") с точностью до 2-х секунд, а хотели, чтобы они равнялись." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьРавенство(_1, _2, ДопСообщениеОшибки = "") Экспорт
	Если _1 <> _2 Тогда
		СообщениеОшибки = "Сравниваемые значения ("+_1+"; "+_2+") не равны, а хотели, чтобы были равны." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьНеРавенство(_1, _2, ДопСообщениеОшибки = "") Экспорт
	Если _1 = _2 Тогда
		СообщениеОшибки = "Сравниваемые значения ("+_1+"; "+_2+") равны, а хотели, чтобы были не равны." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьБольше(_Больше, _Меньше, ДопСообщениеОшибки = "") Экспорт
	Если _Больше <= _Меньше Тогда
		СообщениеОшибки = "Первый параметр ("+_Больше+") меньше или равен второму ("+_Меньше+") а хотели, чтобы был больше." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьБольшеИлиРавно(_Больше, _Меньше, ДопСообщениеОшибки = "") Экспорт
	Если _Больше < _Меньше Тогда
		СообщениеОшибки = "Первый параметр ("+_Больше+") меньше второго ("+_Меньше+") а хотели, чтобы был больше или равен." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьМеньше(проверяемоеЗначение1, проверяемоеЗначение2, СообщениеОбОшибке = "") Экспорт
	Если проверяемоеЗначение1 >= проверяемоеЗначение2 Тогда
		СообщениеОшибки = "Значение <"+проверяемоеЗначение1+"> больше или равно, чем <"+проверяемоеЗначение2+">, а ожидалось меньше"+
				ФорматДСО(СообщениеОбОшибке);
		ВызватьОшибкуПроверки(СообщениеОшибки)
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьМеньшеИлиРавно(проверяемоеЗначение1, проверяемоеЗначение2, СообщениеОбОшибке = "") Экспорт
	Если проверяемоеЗначение1 > проверяемоеЗначение2 Тогда
		СообщениеОшибки = "Значение <"+проверяемоеЗначение1+"> больше, чем <"+проверяемоеЗначение2+">, а ожидалось меньше или равно"+
				ФорматДСО(СообщениеОбОшибке);
		ВызватьОшибкуПроверки(СообщениеОшибки)
	КонецЕсли; 
КонецПроцедуры

Процедура ПроверитьВыполнилось(Знач СтрокаАлгоритм, ПараметрыИлиДопСообщениеОшибки = Неопределено, Знач ДопСообщениеОшибки = "") Экспорт
	Перем Параметры;
	
	Если ТипЗнч(ПараметрыИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = ПараметрыИлиДопСообщениеОшибки;
	Иначе
		Параметры = ПараметрыИлиДопСообщениеОшибки;
	КонецЕсли;
	Попытка
		Выполнить(СтрокаАлгоритм);
	Исключение
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		СообщениеОшибки = "Хотели, чтобы алгоритм """+СтрокаАлгоритм+""" выполнился, а он упал с ошибкой """+ПолученноеОписаниеОшибки+"""." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецПопытки;
	
КонецПроцедуры

Процедура ПроверитьМетодВыполнился(Объект, Знач ИмяМетода, ПараметрыИлиДопСообщениеОшибки = Неопределено, Знач ДопСообщениеОшибки = "") Экспорт
	Перем Параметры;
	
	Если ТипЗнч(ПараметрыИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = ПараметрыИлиДопСообщениеОшибки;
	Иначе
		Параметры = ПараметрыИлиДопСообщениеОшибки;
		Если Параметры <> Неопределено Тогда
			ТипПараметра = ТипЗнч(Параметры);
			Если ТипПараметра <> Тип("Массив") Тогда
				ВызватьИсключение ("Ожидали, что вторым параметром будет передан массив параметров для метода <"+ИмяМетода+">, а получили другой объект с типом <"+ТипПараметра+">");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ПараметрыСтрока = ПараметрыСтрокой(Параметры);
	
	СтрокаВыполнения = "Объект." + ИмяМетода + "(" + ПараметрыСтрока + ")";
	
	Попытка
		Выполнить(СтрокаВыполнения);
	Исключение
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		СообщениеОшибки = "Хотели, чтобы код """+СтрокаВыполнения+""" выполнился, а он упал с ошибкой """+ПолученноеОписаниеОшибки+"""." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецПопытки;
	
КонецПроцедуры

Функция ПараметрыСтрокой(Параметры, ИмяПеременной = "Параметры")
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено Тогда
		Если ТипЗнч(Параметры) = Тип("Массив") Тогда
			Для Индекс = 0 По Параметры.ВГраница() Цикл 
				ПараметрыСтрока = ПараметрыСтрока + ", " + ИмяПеременной + "[" + Формат(Индекс, "ЧН=0; ЧГ=0") + "]";
			КонецЦикла;
			ПараметрыСтрока = Сред(ПараметрыСтрока, 3);
		Иначе
			ПараметрыСтрока = ИмяПеременной;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПараметрыСтрока;
	
КонецФункции

Процедура ПроверитьНеВыполнилось(Знач СтрокаАлгоритм, ПараметрыИлиОжидаемоеОписаниеОшибки, Знач ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки = "", Знач ДопСообщениеОшибки = "") Экспорт
	Перем Параметры, ОжидаемоеОписаниеОшибки; 
	Если ТипЗнч(ПараметрыИлиОжидаемоеОписаниеОшибки) = Тип("Строка") Тогда
		ОжидаемоеОписаниеОшибки = ПараметрыИлиОжидаемоеОписаниеОшибки;
		ДопСообщениеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	Иначе
		Параметры = ПараметрыИлиОжидаемоеОписаниеОшибки;
		ОжидаемоеОписаниеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	КонецЕсли;
	Попытка
		Выполнить(СтрокаАлгоритм);
	Исключение
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если Найти(ПолученноеОписаниеОшибки, ОжидаемоеОписаниеОшибки) = 0 Тогда
			ВызватьОшибкуПроверки("Хотели, чтобы алгоритм """+СтрокаАлгоритм+""" упал с сообщением об ошибке """+ОжидаемоеОписаниеОшибки+""", а он упал с сообщением """+ПолученноеОписаниеОшибки+"""." + ФорматДСО(ДопСообщениеОшибки));
		КонецЕсли;
		Возврат;
	КонецПопытки;
	
	ВызватьОшибкуПроверки("Хотели, чтобы алгоритм """+СтрокаАлгоритм+""" упал, а он выполнился" + ФорматДСО(ДопСообщениеОшибки));
	
КонецПроцедуры

Процедура ПроверитьМетодНеВыполнился(Объект, ИмяМетода, ПараметрыИлиОжидаемоеОписаниеОшибки, Знач ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки = "", Знач ДопСообщениеОшибки = "") Экспорт
	Перем Параметры, ОжидаемоеОписаниеОшибки; 
	
	Если ТипЗнч(ПараметрыИлиОжидаемоеОписаниеОшибки) = Тип("Строка") Тогда
		ОжидаемоеОписаниеОшибки = ПараметрыИлиОжидаемоеОписаниеОшибки;
		ДопСообщениеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	Иначе
		Параметры = ПараметрыИлиОжидаемоеОписаниеОшибки;
		Если Параметры <> Неопределено Тогда
			ТипПараметра = ТипЗнч(Параметры);
			Если ТипПараметра <> Тип("Массив") Тогда
				ВызватьИсключение ("Ожидали, что третьим параметром будет передан массив параметров для метода <"+ИмяМетода+">, а получили другой объект с типом <"+ТипПараметра+">");
			КонецЕсли;
		КонецЕсли;
		ОжидаемоеОписаниеОшибки = ОжидаемоеОписаниеОшибкиИлиДопСообщениеОшибки;
	КонецЕсли;
	
	ПараметрыСтрока = ПараметрыСтрокой(Параметры);
	
	СтрокаВыполнения = "Объект." + ИмяМетода + "(" + ПараметрыСтрока + ")";
	
	Попытка
		Выполнить(СтрокаВыполнения);
	Исключение
		ПолученноеОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если Найти(ПолученноеОписаниеОшибки, ОжидаемоеОписаниеОшибки) = 0 Тогда
			ВызватьОшибкуПроверки("Хотели, чтобы код """+СтрокаВыполнения+""" упал с сообщением об ошибке """+ОжидаемоеОписаниеОшибки+""", а он упал с сообщением """+ПолученноеОписаниеОшибки+"""." + ФорматДСО(ДопСообщениеОшибки));
		КонецЕсли;
		Возврат;
	КонецПопытки;
	
	ВызватьОшибкуПроверки("Хотели, чтобы код """+СтрокаВыполнения+""" упал, а он выполнился" + ФорматДСО(ДопСообщениеОшибки));
	
КонецПроцедуры

// проверка идет через ЗначениеЗаполнено, но мутабельные значение всегда считаем заполненными
Процедура ПроверитьЗаполненность(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
	Попытка
		фЗаполнено = ЗначениеЗаполнено(ПроверяемоеЗначение);
	Исключение
		Возврат;
	КонецПопытки;
	Если НЕ фЗаполнено Тогда
		ВызватьОшибкуПроверки("Значение ("+ПроверяемоеЗначение+") не заполнено, а ожидалась заполненность" + ФорматДСО(ДопСообщениеОшибки));
	КонецЕсли; 
КонецПроцедуры

Процедура ПроверитьНеЗаполненность(ПроверяемоеЗначение, ДопСообщениеОшибки = "") Экспорт
	СообщениеОшибки = "Значение ("+ПроверяемоеЗначение+") заполнено, а ожидалась незаполненность" + ФорматДСО(ДопСообщениеОшибки);
	Попытка
		фЗаполнено = ЗначениеЗаполнено(ПроверяемоеЗначение);
	Исключение
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецПопытки;
	Если фЗаполнено Тогда
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли; 
КонецПроцедуры

Процедура ПроверитьТип(значение, ТипИлиИмяТипа, ДопСообщениеОшибки = "") Экспорт
	Если ТипЗнч(ТипИлиИмяТипа) = Тип("Строка") Тогда
		искомыйТип = Тип(ТипИлиИмяТипа);
	ИначеЕсли ТипЗнч(ТипИлиИмяТипа) = Тип("Тип") Тогда
		искомыйТип = ТипИлиИмяТипа;
	Иначе
		ВызватьИсключение ("ПроверитьТип: Тип значения параметра ТипИлиИмяТипа должен быть <Тип> или <Строка>, а получили <"+ ТипЗнч(ТипИлиИмяТипа) + ">" + ФорматДСО(ДопСообщениеОшибки));
	КонецЕсли;
	Если ТипЗнч(значение) <> искомыйТип Тогда
		ВызватьОшибкуПроверки("Типом значения <"+значение+"> является <"+ТипЗнч(значение)+">, а ожидался тип <"+ТипИлиИмяТипа+">."+ФорматДСО(ДопСообщениеОшибки));
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьВхождение(строка, подстрокаПоиска, ДопСообщениеОшибки = "") Экспорт
	Если Найти(строка, подстрокаПоиска) = 0 Тогда
		ПредставлениеСтроки = "<"+строка+">";
		Если СтрДлина(строка) > 20 Тогда
			ПредставлениеСтроки = ПредставлениеСтроки + Символы.ПС;
		КонецЕсли;
		ПредставлениеПодСтроки = "<"+подстрокаПоиска+">";
		Если СтрДлина(подстрокаПоиска) > 20 Тогда
			ПредставлениеПодСтроки = ПредставлениеПодСтроки + Символы.ПС;
		КонецЕсли;
		СообщениеОшибки = "Искали в "+ПредставлениеСтроки+" подстроку "+ПредставлениеПодСтроки+", но не нашли." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

//Коллекция - Массив, Структура, Соответствие, ФиксированныйМассив, ФиксированнаяСтруктура, ФиксированноеСоответствие, СписокЗначений
Процедура ПроверитьВхождениеВКоллекцию(Элемент, Коллекция, ДопСообщениеОшибки = "") Экспорт
	Нашли = Неопределено;
	ТипКоллекции = ТипЗнч(Коллекция);
	Если ТипКоллекции = Тип("Массив") или ТипКоллекции = Тип("ФиксированныйМассив") Тогда
		Нашли = Коллекция.Найти(Элемент) <> Неопределено;
	ИначеЕсли ТипКоллекции = Тип("Структура") или ТипКоллекции = Тип("Соответствие") 
			или ТипКоллекции = Тип("ФиксированнаяСтруктура") или ТипКоллекции = Тип("ФиксированноеСоответствие") Тогда
		Для каждого КлючЗначение Из Коллекция Цикл
			Нашли = КлючЗначение.Значение = Элемент;
			Если Нашли Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипКоллекции = Тип("СписокЗначений") Тогда
		Нашли = Коллекция.НайтиПоЗначению(Элемент) <> Неопределено;
	КонецЕсли;
	Если Нашли = Неопределено Тогда
		СообщениеОшибки = "Утверждение ""ПроверитьВхождениеВКоллекцию"" не умеет работать с типом коллекции <"+ТипКоллекции+">." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьИсключение СообщениеОшибки;
	КонецЕсли;
	Если Не Нашли Тогда
		СообщениеОшибки = "Не нашли элемент <"+Элемент+"> в коллекции, а хотели, чтобы он был в коллекции." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ПроверитьВалидностьЗапросаСКД(ТекстЗапроса, ДопСообщениеОшибки = "") Экспорт
	
	СхемаКомпоновкиДанных = Новый СхемаКомпоновкиДанных;
	
	ИсточникДанных 					  = СхемаКомпоновкиДанных.ИсточникиДанных.Добавить(); 
	ИсточникДанных.Имя                = "ИсточникДанных";
	ИсточникДанных.СтрокаСоединения   = "";
	ИсточникДанных.ТипИсточникаДанных = "Local";
	
	НаборДанных 							 = СхемаКомпоновкиДанных.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя            				 = "НаборДанных";
	НаборДанных.ИсточникДанных 				 = "ИсточникДанных";
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;
	НаборДанных.Запрос 						 = ТекстЗапроса;
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	Попытка
		КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	Исключение
		СообщениеОшибки = ОписаниеОшибки() + "." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецПопытки;
	
КонецПроцедуры // ПроверитьВалидностьЗапросаСКД()

Процедура ПроверитьНаличиеОбъектаИБ(ссылка, ДопСообщениеОшибки = "") Экспорт
	Если Не ЗначениеЗаполнено(ссылка) Тогда
		СообщениеОшибки = "Ожидали заполненность ссылки, а получили пустую ссылку." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
	лОбъект = ссылка.ПолучитьОбъект();
	Если лОбъект = Неопределено Тогда
		СообщениеОшибки = "Ожидали существование объекта в ИБ, а получили объект не найден <" + ссылка + "> ." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

// Проеряет равенство файлов
// Параметры:
//  ПутьФайла1, ПутьФайла2 - полные пути к фалйам
//  ПарамСравнениеФайлов - структура с ключами:
//                ИгнорироватьПустоеПространство
//                СпособСравнения
//                УчитыватьРазделителиСтрок
//                УчитыватьРегистр
//  ПоказатьРазличия - в случае ошибки появляется окно сравнеия (для отладки)
Процедура ПроверитьРавенствоФайлов(ПутьФайла1, ПутьФайла2, ДопСообщениеОшибки = "", ПарамСравнениеФайлов = Неопределено, ПоказатьРазличия = Ложь) Экспорт
#Если ТолстыйКлиентОбычноеПриложение или ТолстыйКлиентУправляемоеПриложение Тогда
	Если ПарамСравнениеФайлов = Неопределено Тогда
		ПарамСравнениеФайлов = Новый Структура;
	КонецЕсли;
	СравнениеФайлов = Новый СравнениеФайлов;
	СравнениеФайлов.ПервыйФайл = ПутьФайла1;
	СравнениеФайлов.ВторойФайл = ПутьФайла2;
	Если Не ПарамСравнениеФайлов.Свойство("СпособСравнения") Тогда
		Файл = Новый Файл(ПутьФайла1);
		ТипФайла = НРег(Файл.Расширение);
		ТекстовыеТипы = ".txt,.xml";
		Если ТипФайла = ".mxl" Тогда
			ПарамСравнениеФайлов.Вставить("СпособСравнения", СпособСравненияФайлов.ТабличныйДокумент);
		ИначеЕсли Найти(ТекстовыеТипы, ТипФайла) > 0 Тогда
			ПарамСравнениеФайлов.Вставить("СпособСравнения", СпособСравненияФайлов.ТекстовыйДокумент);
		КонецЕсли;
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(СравнениеФайлов, ПарамСравнениеФайлов);
	ФайлыИдентичны = СравнениеФайлов.Сравнить();
	Если Не ФайлыИдентичны Тогда
		Если ПоказатьРазличия Тогда // для удобства отладки и расследования ошибок
			СравнениеФайлов.ПоказатьРазличия();
		КонецЕсли;
		СообщениеОшибки = "Ожидали идентичность файлов, а получили, что они различны." + ФорматДСО(ДопСообщениеОшибки);
		ВызватьОшибкуПроверки(СообщениеОшибки);
	КонецЕсли;
#Иначе 
	ВызватьИсключение "Утверждение ПроверитьРавенствоФайлов можно использовать только в толстом клиенте!";
#КонецЕсли
КонецПроцедуры


Процедура ПроверитьРавенствоТаблиц(Таб1, Таб2, ДопСообщениеОшибки = "") Экспорт
	
	Если ТипЗнч(Таб1) <> Тип("ТаблицаЗначений") Тогда
		ВызватьИсключение "ПроверитьРавенствоТаблиц: Первый параметр-таблица таблицей не является";
	КонецЕсли;
	Если ТипЗнч(Таб1) <> Тип("ТаблицаЗначений") Тогда
		ВызватьИсключение "ПроверитьРавенствоТаблиц: Второй параметр-таблица таблицей не является";
	КонецЕсли;
	
	Различия = Новый ТаблицаЗначений;
	РезультатСравнения = СравнитьТаблицы(Таб1, Таб2, Различия);
	
	Если РезультатыСравненияТаблиц.ТаблицыСовпадают <> РезультатСравнения Тогда
		
		ИменаРезультатов = Новый Соответствие;
		Для Каждого КлючЗначение Из РезультатыСравненияТаблиц Цикл
			ИменаРезультатов.Вставить(КлючЗначение.Значение, КлючЗначение.Ключ);
		КонецЦикла; 
		СтрокаОшибок = "Различия в таблицах:" + Символы.ПС;
		СтрокаОшибок = СтрокаОшибок + "Ожидали статус <" + ИменаРезультатов[РезультатыСравненияТаблиц.ТаблицыСовпадают] + ">, а получили <" + ИменаРезультатов[РезультатСравнения] + ">" + Символы.ПС;
		Для Каждого Строка Из Различия Цикл
			СтрокаОшибок = СтрокаОшибок + "Значение [" + Строка.Колонка + ":" + Строка.Строка + "]. Ожидали <" + Строка.Ожидание + ">, а получили <" + Строка.Результат + ">" + Символы.ПС;
		КонецЦикла;
		
		ВызватьОшибкуПроверки("Таблицы должны совпадать, а они различны" + Символы.ПС + СтрокаОшибок + Символы.ПС + ДопСообщениеОшибки);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям(ТабДок1, ТабДок2, УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки = Ложь, УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки = Ложь, Знач ДопСообщениеОшибки = "") Экспорт
	
	Если ТипЗнч(ТабДок1) <> Тип("ТабличныйДокумент") Тогда
		ВызватьИсключение "ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям: Первый параметр-таблица не является табличным документов";
	КонецЕсли;
	Если ТипЗнч(ТабДок2) <> Тип("ТабличныйДокумент") Тогда
		ВызватьИсключение "ПроверитьРавенствоТабличныхДокументовТолькоПоЗначениям: Второй параметр-таблица не является табличным документов";
	КонецЕсли;
	
	УчитыватьТолькоВидимыеКолонки = Ложь;
	Если ТипЗнч(УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки) = Тип("Булево") Тогда
		УчитыватьТолькоВидимыеКолонки = УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки;
	ИначеЕсли ТипЗнч(УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = УчитыватьТолькоВидимыеКолонкиИлиДопСообщениеОшибки;
	КонецЕсли;
	УчитыватьТолькоВидимыеСтроки = Ложь;
	Если ТипЗнч(УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки) = Тип("Булево") Тогда
		УчитыватьТолькоВидимыеСтроки = УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки;
	ИначеЕсли ТипЗнч(УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки) = Тип("Строка") Тогда
		ДопСообщениеОшибки = УчитыватьТолькоВидимыеСтрокиИлиДопСообщениеОшибки;
	КонецЕсли;
	
	Таб1 = ПолучитьТаблицуЗначенийИзТабличногоДокумента(ТабДок1, УчитыватьТолькоВидимыеКолонки, УчитыватьТолькоВидимыеСтроки);
	Таб2 = ПолучитьТаблицуЗначенийИзТабличногоДокумента(ТабДок2, УчитыватьТолькоВидимыеКолонки, УчитыватьТолькоВидимыеСтроки);
	
	ПроверитьРавенствоТаблиц(Таб1, Таб2, ДопСообщениеОшибки);
	
КонецПроцедуры

Процедура ВызватьОшибкуПроверки(СообщениеОшибки)
	
	Префикс = "["+ СтатусыРезультатаТестирования.ОшибкаПроверки + "]";
	ВызватьИсключение Префикс + " " + СообщениеОшибки;
	
КонецПроцедуры

Процедура ПропуститьТест(Знач Сообщение = "") Экспорт
	
	Префикс = "[" + СтатусыРезультатаТестирования.ТестПропущен + "]";
	Если ПустаяСтрока(Сообщение) Тогда
		Сообщение = НСтр("ru = 'Тест пропущен'");
	КонецЕсли;
	ВызватьИсключение Префикс + " " + Сообщение;
	
КонецПроцедуры

// портирован из Functest
Функция ПолучитьТаблицуЗначенийИзТабличногоДокумента(ТабличныйДокумент, УчитыватьТолькоВидимыеКолонки = Ложь, УчитыватьТолькоВидимыеСтроки = Ложь)
	
	ТипТабличногоДокумента = ТипЗнч(ТабличныйДокумент);
	Если ТипТабличногоДокумента <> Тип("ТабличныйДокумент") И ТипТабличногоДокумента <> Тип("ПолеТабличногоДокумента") Тогда
		ВызватьИсключение "ПолучитьТаблицуЗначенийИзТабличногоДокумента: Требуется тип ТабличныйДокумент или ПолеТабличногоДокумента";
	КонецЕсли;
	
	НомерПоследнейКолонки = ТабличныйДокумент.ШиринаТаблицы;
	НомерПоследнейСтроки = ТабличныйДокумент.ВысотаТаблицы;
	
	НоваяТаблицаЗначений = Новый ТаблицаЗначений;
	Колонки = НоваяТаблицаЗначений.Колонки;
	ТипСтрока = Новый ОписаниеТипов("Строка");
	
	// TODO При определении видимости не учитывается наличие нескольких форматов строк, сейчас видимоcть колонки определяется по формату первой строки
	УчитываемыеКолонки = Новый Массив;
	Для НомерКолонки = 1 По НомерПоследнейКолонки Цикл
		ОбластьКолонки = ТабличныйДокумент.Область(0, НомерКолонки, 1, НомерКолонки);
		
		УчитыватьКолонку = Не УчитыватьТолькоВидимыеКолонки Или ОбластьКолонки.Видимость;
		Если УчитыватьКолонку Тогда
			УчитываемыеКолонки.Добавить(НомерКолонки);
			ШиринаКолонки = ОбластьКолонки.ШиринаКолонки;
			Если ШиринаКолонки <= 1 Тогда
				ШиринаКолонки = 1;
			КонецЕсли;
			ИмяКолонки = "К" + Формат(Колонки.Количество() + 1, "ЧН=; ЧГ=0");
			Колонки.Добавить(ИмяКолонки, ТипСтрока, ИмяКолонки, ШиринаКолонки);
		КонецЕсли;
	КонецЦикла;
	
	ГраницаКолонок = УчитываемыеКолонки.ВГраница();
	Для НомерСтроки = 1 По НомерПоследнейСтроки Цикл
		
		Если УчитыватьТолькоВидимыеСтроки И Не ТабличныйДокумент.Область(НомерСтроки,, НомерСтроки).Видимость Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = НоваяТаблицаЗначений.Добавить();
		
		Для Индекс = 0 По ГраницаКолонок Цикл
			НомерКолонки = УчитываемыеКолонки[Индекс];
			Область = ТабличныйДокумент.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			НоваяСтрока[Индекс] = Область.Текст;
		КонецЦикла;
	КонецЦикла;
	
	Возврат НоваяТаблицаЗначений;
	
КонецФункции

//}

//{ МЕТОДЫ ДЛЯ ИСПОЛЬЗОВАНИЯ ИЗ ОБРАБОТОК ТЕСТИРОВАНИЯ

Функция ПолучитьКонтекст(Знач ИдентификаторКонтекста = Неопределено) Экспорт
	Перем Контекст;
	
	Если ИдентификаторКонтекста = Неопределено Тогда
		ИдентификаторКонтекста = ИдентификаторПустогоКонтекста();
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ЭтотОбъект.Мир) Или Не ЭтотОбъект.Мир.Свойство(ИдентификаторКонтекста, Контекст) Тогда
		ТекстОшибки = СтрЗаменить(НСтр("ru = 'Отсутствует запрашиваемый контекст%1.'"), "%1", ?(ИдентификаторКонтекста = ИдентификаторПустогоКонтекста(), "", " (" + ИдентификаторКонтекста + ")"));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат Контекст;
	
КонецФункции

Процедура УстановитьКонтекст(Контекст, Знач ИдентификаторКонтекста = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(ЭтотОбъект.Мир) Тогда
		ЭтотОбъект.Мир = Новый Структура;
	КонецЕсли;
	
	Если ИдентификаторКонтекста = Неопределено Тогда
		ИдентификаторКонтекста = ИдентификаторПустогоКонтекста();
	КонецЕсли;
	
	ЭтотОбъект.Мир.Вставить(ИдентификаторКонтекста, Контекст);
	
КонецПроцедуры

Функция КонтекстУстановлен(Знач ИдентификаторКонтекста = Неопределено) Экспорт
	
	Если ИдентификаторКонтекста = Неопределено Тогда
		ИдентификаторКонтекста = ИдентификаторПустогоКонтекста();
	КонецЕсли;
	
	Возврат ЗначениеЗаполнено(ЭтотОбъект.Мир) И ЭтотОбъект.Мир.Свойство(ИдентификаторКонтекста);
	
КонецФункции

Процедура УдалитьКонтекст(Знач ИдентификаторКонтекста = Неопределено) Экспорт
	
	Если ИдентификаторКонтекста = Неопределено Тогда
		ИдентификаторКонтекста = ИдентификаторПустогоКонтекста();
	КонецЕсли;
	
	Если КонтекстУстановлен(ИдентификаторКонтекста) Тогда
		ЭтотОбъект.Мир.Удалить(ИдентификаторКонтекста);
	КонецЕсли;
	
КонецПроцедуры

// Создает новый набор тестов.
// 
Функция Новый_НаборТестов() Экспорт
	Возврат Новый Массив;
КонецФункции

// Добавляет новый тестовый случай в набор.
// 
Функция НаборТестов_Добавить(НаборТестов, ИмяТестовогоСлучая, П1=Неопределено, П2=Неопределено, П3=Неопределено, П4=Неопределено, П5=Неопределено, П6=Неопределено, П7=Неопределено) Экспорт
	
	НаборТестов.Добавить(ИмяТестовогоСлучая);
	Возврат НаборТестов;
	
КонецФункции

// Выводит сообщение. В тестах ВСЕГДА должна использоваться ВМЕСТО метода Сообщить().
// 
Функция ВывестиСообщение(ТекстСообщения, Статус=Неопределено) Экспорт	
	
	Если mMiddleMan <> Неопределено Тогда
		Если НЕ ОповеститьОСобытии("Message", ТекстСообщения) Тогда
			ОповеститьОСобытии("ВывестиСообщение", ТекстСообщения);
		КонецЕсли;
	Иначе
		Если ВыводЛогаВФорматеTeamCity Тогда
			ТекстСообщения = СтрЗаменить(ТекстСообщения,"|","||");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,"'","|'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,"[","|[");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,"]","|]");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,Символы.ВК,"|r");
			ТекстСообщения = СтрЗаменить(ТекстСообщения,Символы.ПС,"|n");
			
			СтатусДляTeamCity = ?(Статус = Неопределено, СтатусСообщения.Обычное, Статус);
			Сообщить("##teamcity[message text='"+ТекстСообщения+"' errorDetails='' status='"+мСоответствиеСтатусовДляTeamCity[СтатусДляTeamCity]+"']");
		Иначе
			Сообщить(ТекстСообщения, Статус);
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

// Вызывает исключение с заданным текстом ошибки для прерывания выполнения тестового случая.
// 
Функция ПрерватьТест(ТекстОшибки) Экспорт
	
	ВызватьИсключение ТекстОшибки;
	
КонецФункции

// создается копия данных текущего теста - структура "Имя, ПолныйПуть, СостояниеТеста"
Функция ДанныеТекущегоТеста() Экспорт
	
	ИдентификаторКонтекста = ИдентификаторКонтекстаДанныхТекущегоТеста();
	Если Не КонтекстУстановлен(ИдентификаторКонтекста) Тогда
		ВызватьИсключение НСтр("ru = 'Нельзя получить данные текущего теста вне режима тестирования'");
	КонецЕсли;
	
	ДанныеТекущегоТеста = ПустыеДанныеТекущегоТеста();
	ЗаполнитьЗначенияСвойств(ДанныеТекущегоТеста, ПолучитьКонтекст(ИдентификаторКонтекста));
	
	Возврат ДанныеТекущегоТеста;
	
КонецФункции

//}

//{ ВНЕШНЕЕ API (для использования из скрипта Снегопата или из COM-подключения).

Функция OpenBrowserForm() Экспорт
	Перем НоваяФорма;
	//#Если ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение Тогда
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		НоваяФорма = ЭтотОбъект.ПолучитьФорму("Форма");
		НоваяФорма.Открыть();
	#ИначеЕсли НаКлиенте Тогда
		Если ЭтоВстроеннаяОбработка Тогда
			НоваяФорма = ОткрытьФорму("Обработка." + Метаданные().Имя + ".Форма.УправляемаяФорма"); 
		Иначе
			НоваяФорма = ОткрытьФорму("ВнешняяОбработка." + Метаданные().Имя + ".Форма.УправляемаяФорма"); 
		КонецЕсли;
	#КонецЕсли
	Возврат НоваяФорма;
КонецФункции

// Устанавливает объект-прокси, который будет получать сообщения 
// о ходе загрузки и выполнения тестов, сообщения, выводимые при 
// выполнении тестов. Для использования в скрипте для Снегопата.
// 
Функция SetHandlerObject(obj) Экспорт
	mMiddleMan = obj;
КонецФункции

// Загружает все тесты из каталога в дерево тестов.
// 
Функция LoadAllTests(ПутьККаталогу) Экспорт
	
	ДеревоТестов.Строки.Очистить();
	
	ЗагрузитьТесты(ДеревоТестов, Новый Файл(ПутьККаталогу));
	
КонецФункции

// Загружает отдельную обработку тестирования в дерево тестов.
// 
Функция LoadTest(ПутьКФайлуТеста) Экспорт
	
	ДеревоТестов.Строки.Очистить();
	
	ЗагрузитьТесты(ДеревоТестов, Новый Файл(ПутьКФайлуТеста));
	
КонецФункции

// Выполняет все тесты, загруженные в дерево тестов.
// 
Функция RunAllTests() Экспорт
	
	#Если Клиент Тогда
		ОчиститьСообщения();
	#КонецЕсли
	
	ПодчиненныеСтроки = ПодчиненныеСтроки(ДеревоТестов);
	
	Если СлучайныйПорядокВыполнения Тогда
		СтрокиДерева = ПолучитьСтрокиДереваВСлучайномПорядке(ПодчиненныеСтроки);
	Иначе
		СтрокиДерева = ПолучитьТолькоТестовыеМетодыИзДерева(ПодчиненныеСтроки);
	КонецЕсли; 
	
	результат = ВыполнитьТесты(СтрокиДерева);
	Возврат результат;
КонецФункции

// Запускает отдельный тест из дерева тестов.
// 
Функция RunTest(TestRow) Экспорт
	
	#Если Клиент Тогда
		ОчиститьСообщения();
	#КонецЕсли
	
	ЗапускаемыеТесты = Новый Массив;
	ЗапускаемыеТесты.Добавить(TestRow);
	результат = ВыполнитьТесты(ЗапускаемыеТесты);
	Возврат результат;
	
КонецФункции

Функция ПолучитьСтрокиДереваВСлучайномПорядке(ИсходныеСтрокиДерева) Экспорт
	Отбор = Новый Структура("РазрешенСлучайныйПорядокВыполнения", Ложь);
	МассивСтрокДерева = ПолучитьТолькоТестовыеМетодыИзДерева(ИсходныеСтрокиДерева, Отбор);
	
	Отбор = Новый Структура("РазрешенСлучайныйПорядокВыполнения", Истина);
	МассивСтрокДереваДляСлучайногоВыполнения = ПолучитьТолькоТестовыеМетодыИзДерева(ИсходныеСтрокиДерева, Отбор);
	
	ПеремешанныеСтрокиДерева = ПеремешатьМассив(МассивСтрокДереваДляСлучайногоВыполнения);
	Для каждого Элем Из ПеремешанныеСтрокиДерева Цикл
		МассивСтрокДерева.Добавить(Элем);
	КонецЦикла;
	
	Возврат МассивСтрокДерева;
КонецФункции

// Рекурсивно из строк дерева тестов запоминает в соответствии в качестве ключа
// только те строки дерева тестов, которые являются тестовыми случаями.
// Возвращает созданное и заполненное тестовыми случаями соответствие.
// 
Функция ПолучитьТолькоТестовыеМетодыИзДерева(ПодчиненныеСтрокиДереваТестов, Отбор = Неопределено, МассивДляДобавления = Неопределено) Экспорт
	Если МассивДляДобавления=Неопределено Тогда
		МассивДляДобавления = Новый Массив;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Отбор) Тогда
		Отбор = Новый Структура;
	КонецЕсли;
	
	Отбор.Вставить("ТипСтроки", мЗначенияТиповСтроки.ТестовыйМетод);
	ОтобранныеСтроки = НайтиСтроки(ПодчиненныеСтрокиДереваТестов, Отбор);
	
	Для Каждого ТестовыйМетод Из ОтобранныеСтроки Цикл
		Если МассивДляДобавления.Найти(ТестовыйМетод) = Неопределено Тогда
			МассивДляДобавления.Добавить(ТестовыйМетод);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого СтрокаДереваТестов Из ПодчиненныеСтрокиДереваТестов Цикл
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли 
		
		Если СтрокаДереваТестов.ТипСтроки <> мЗначенияТиповСтроки.ТестовыйМетод Тогда
			ПолучитьТолькоТестовыеМетодыИзДерева(ПодчиненныеСтроки(СтрокаДереваТестов), Отбор, МассивДляДобавления);
		КонецЕсли;
				
	КонецЦикла;
	
	Возврат МассивДляДобавления;
	
КонецФункции

Функция НайтиСтроки(НаборСтрок, Отбор)
	ИщемПеребором = Истина;
	#Если ТолстыйКлиентОбычноеПриложение или ТолстыйКлиентУправляемоеПриложение Тогда
		ИщемПеребором = ТипЗнч(НаборСтрок) = Тип("ВыделенныеСтрокиТабличногоПоля");
	#КонецЕсли
	Если ИщемПеребором Тогда
		Рез = Новый Массив;
		Для каждого Строка Из НаборСтрок Цикл
			Нашли = Истина;
			Для каждого КлючЗначение Из Отбор Цикл
				КлючОтбора = КлючЗначение.Ключ;
				Если Строка[КлючОтбора] <> Отбор[КлючОтбора] Тогда
					Нашли = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Нашли Тогда
				Рез.Добавить(Строка);
			КонецЕсли;
		КонецЦикла;
	Иначе
		Рез = НаборСтрок.НайтиСтроки(Отбор);
	КонецЕсли;
	Возврат Рез;
КонецФункции

Функция ПеремешатьМассив(ИсходныйМассив) Экспорт
	
	Результат = Новый Массив;
	Для Каждого Элемент Из ИсходныйМассив Цикл
		Результат.Добавить(Элемент);
	КонецЦикла;
	
	// алгоритм перемешивания взят из книги Кнута "Искусство программирования" т.2
	ГСЧ = Новый ГенераторСлучайныхЧисел();
	ПоследнийИндекс = Результат.ВГраница();
	Для Индекс = 1 По ПоследнийИндекс Цикл
		ТекущийИндекс = ПоследнийИндекс - Индекс + 1;
		НовыйИндекс = ГСЧ.СлучайноеЧисло(0, ТекущийИндекс);
		Если НовыйИндекс <> ТекущийИндекс Тогда
			Значение = Результат[НовыйИндекс];
			Результат[НовыйИндекс] = Результат[ТекущийИндекс];
			Результат[ТекущийИндекс] = Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

//}

// { Методы генерации тестовых данных

Функция СоздатьДанныеПоМакетам(ТестОбъект, ИменаМакетов) Экспорт
	МассивИменМакетов = РазложитьСтрокуВМассивПодстрок(ИменаМакетов);
	МассивМакетов = Новый Массив;
	Для каждого ИмяМакета Из МассивИменМакетов Цикл
		МассивМакетов.Добавить(ТестОбъект.ПолучитьМакет(ИмяМакета));
	КонецЦикла;
	Возврат СоздатьДанныеПоТабличномуДокументу(МассивМакетов);
КонецФункции

Функция СоздатьДанныеПоТабличномуДокументу(ТабличныйДокументИлиМассивТабличныхДокументов, РежимыЗагрузкиИлиИмяКолонкиЗамещения = Неопределено, ИмяКолонкиЗамещения = Неопределено) Экспорт
	Перем РежимыЗагрузки;
	
	Если ТипЗнч(РежимыЗагрузкиИлиИмяКолонкиЗамещения) = Тип("Строка") Тогда
		ИмяКолонкиЗамещения = РежимыЗагрузкиИлиИмяКолонкиЗамещения;
	Иначе
		РежимыЗагрузки = РежимыЗагрузкиИлиИмяКолонкиЗамещения;
		Если РежимыЗагрузки <> Неопределено Тогда
			ТипПараметра = ТипЗнч(РежимыЗагрузки);
			Если ТипПараметра <> Тип("Структура") Тогда
				ВызватьИсключение ("Ожидали, что вторым параметром будет передана структура параметров для метода <СоздатьДанныеПоТабличномуДокументу>, а получили другой объект с типом <"+ТипПараметра+">");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	МассивТабличныхДокументов = Новый Массив();
	Если ТипЗнч(ТабличныйДокументИлиМассивТабличныхДокументов) = Тип("ТабличныйДокумент") Тогда
		МассивТабличныхДокументов.Добавить(ТабличныйДокументИлиМассивТабличныхДокументов);
	ИначеЕсли ТипЗнч(ТабличныйДокументИлиМассивТабличныхДокументов) = Тип("Массив") Тогда
		МассивТабличныхДокументов = ТабличныйДокументИлиМассивТабличныхДокументов;
	КонецЕсли;
	Возврат СоздатьДанныеИзМакетов(МассивТабличныхДокументов, РежимыЗагрузки, ИмяКолонкиЗамещения);
КонецФункции

// удаляет созданные элементы (Справочники, Документы, Пользователи ИБ), регистры сведений не чистит - есть тесты
Функция УдалитьСозданныеДанные(Данные) Экспорт
	// обратный порядок нужен для получения правильного количества удаленных элементов, т.к Владелец.Удалить удаляет и подчиненные элементы из подчиненных справочников
	массивВОбратномПорядке = Новый Массив;
	Для каждого ключЗначение Из Данные Цикл
		массивВОбратномПорядке.Вставить(0, КлючЗначение.Значение);
	КонецЦикла;
	
	количествоУдаленных = 0;
	Для каждого элем Из массивВОбратномПорядке Цикл
		типЭлемента = ТипЗнч(элем);
		Если Справочники.ТипВсеСсылки().СодержитТип(типЭлемента) Тогда
			объект = элем.ПолучитьОбъект();
			Если объект <> Неопределено Тогда
				Попытка
					объект.Удалить();
					количествоУдаленных = количествоУдаленных + 1;
				Исключение
					Сообщить(ОписаниеОшибки());
				КонецПопытки;
			КонецЕсли; 
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(типЭлемента) Тогда
			объект = элем.ПолучитьОбъект();
			Если объект <> Неопределено Тогда
				Попытка
					объект.Удалить();
					количествоУдаленных = количествоУдаленных + 1;
				Исключение
					Сообщить(ОписаниеОшибки());
				КонецПопытки;
			КонецЕсли; 
		ИначеЕсли типЭлемента = Тип("ПользовательИнформационнойБазы") Тогда
			Попытка
				элем.Удалить();
				количествоУдаленных = количествоУдаленных + 1;
			Исключение
				Сообщить(ОписаниеОшибки());
			КонецПопытки;
		КонецЕсли; 
	КонецЦикла;
	Возврат количествоУдаленных;
КонецФункции

Функция СоздатьДанныеИзМакетов(МассивТабличныхДокументов, РежимыЗагрузки, ИмяКолонкиЗамещения)
	ПротоДанные = Новый Структура;
	Для каждого ТабличныйДокумент Из МассивТабличныхДокументов Цикл
		ПрочитатьДанныеИзМакета(ПротоДанные,ТабличныйДокумент,ИмяКолонкиЗамещения);
	КонецЦикла;
	ЗаменитьРежимыЗагрузки(ПротоДанные, РежимыЗагрузки);
	Данные = СоздатьТестовыеДанныеПоПротоДанным(ПротоДанные);
	Возврат Данные;
КонецФункции

Функция ПрочитатьДанныеИзМакета(ПротоДанные,ТабличныйДокумент,ИмяКолонкиЗамещения)
	
	СтрокаМакета = 1;
	НомерКолонкиМакета = 0;
	КолонкиМакета = КолонкиМакетаДанных();
	Пока НомерКолонкиМакета<ТабличныйДокумент.ШиринаТаблицы Цикл
		НомерКолонкиМакета = НомерКолонкиМакета + 1;
		ИмяКолонки = ТабличныйДокумент.Область("R" + 1 + "C" + НомерКолонкиМакета).Текст;
		Если Не ПустаяСтрока(ИмяКолонки) Тогда
			КолонкиМакета.Вставить(ИмяКолонки,НомерКолонкиМакета);
		КонецЕсли;
	КонецЦикла;
	
	ПроверитьКолонки(КолонкиМакета,ИмяКолонкиЗамещения);

	ДействиеТекущейСтроки = Неопределено;
	Пока СтрокаМакета<ТабличныйДокумент.ВысотаТаблицы Цикл
		СтрокаМакета = СтрокаМакета + 1;
		НомерСтроки = Формат(СтрокаМакета, "ЧГ=");
		
		//Если новый объект
		ИмяПеременной = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ИмяПеременной);
		Если Не ПустаяСтрока(ИмяПеременной) Тогда
			Если ПротоДанные.Свойство(ИмяПеременной) Тогда
				ВызватьИсключение "Ошибка при создании данных из макета! Неуникальное имя переменной: ["+ИмяПеременной+"]";
			КонецЕсли;
			
			Тип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Тип);
			Вид = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Вид);
			Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
			Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);			
			
			ПротоОбъект = СоздатьСтруктуруОписанияОбъекта();
			ПротоОбъект.ИмяПеременной = ИмяПеременной;
			ПротоОбъект.Тип = Тип;
			ПротоОбъект.Вид = Вид;
			ПротоОбъект.ИмяПредопределенного = Значение;
			ПротоОбъект.ПоляОбъекта = СоздатьТаблицуОписанияПолей();
			Если Не ПустаяСтрока(Режим) Тогда
				Если ПротоОбъект.Режимы.Свойство(Режим) Тогда
					ПротоОбъект.Режимы[Режим] = Истина;
				КонецЕсли;
			КонецЕсли;
			
			ПротоДанные.Вставить(ИмяПеременной,ПротоОбъект);
			ДействиеТекущейСтроки = "ЧитаемПоляОбъекта";
			Продолжить;
		КонецЕсли;
		
		//Табличные части
		ИмяТабЧасти = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ТЧ);
		Если Не ПустаяСтрока(ИмяТабЧасти) Тогда
			Если ВРег(ИмяТабЧасти)="XDDMODS" или ВРег(ИмяТабЧасти)="XDDDATAGEN" Тогда
				ДействиеТекущейСтроки = "ЧитаемРежимы";
				Продолжить;
			КонецЕсли;
			Если ВРег(ИмяТабЧасти)="ДОПОЛНИТЕЛЬНЫЕСВОЙСТВА" Тогда
				ДействиеТекущейСтроки = "ЧитаемДопСвойства";
				Продолжить;
			КонецЕсли;
			Если ВРег(ИмяТабЧасти)="ОБМЕНДАННЫМИ" Тогда
				ДействиеТекущейСтроки = "ЧитаемОбменДанными";
				Продолжить;
			КонецЕсли;
			
			ТабЧасть = Неопределено;
			Если Не ПротоОбъект.ТабличныеЧасти.Свойство(ИмяТабЧасти,ТабЧасть) Тогда
				//Новая ТабЧасть
				ОписаниеПолейТЧ = СоздатьТаблицуОписанияПолей();
				ТабЧасть = Новый Массив;
				ТабЧасть.Добавить(ОписаниеПолейТЧ);
				ПротоОбъект.ТабличныеЧасти.Вставить(ИмяТабЧасти,ТабЧасть);
				ДействиеТекущейСтроки = "ЧитаемТабЧасть";
				Продолжить;
			Иначе
				//Новая строка ТабЧасти
				ОписаниеПолейТЧ = СоздатьТаблицуОписанияПолей();
				ТабЧасть.Добавить(ОписаниеПолейТЧ);
				ДействиеТекущейСтроки = "ЧитаемТабЧасть";
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		//Поля объекта
		Если ДействиеТекущейСтроки = "ЧитаемПоляОбъекта" Тогда
			ИмяРеквизита = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент, НомерСтроки, КолонкиМакета.Реквизит);
			Если Не ПустаяСтрока(ИмяРеквизита) Тогда
				НовоеПолеОбъекта = ПротоОбъект.ПоляОбъекта.Добавить();
				НовоеПолеОбъекта.Имя = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Реквизит);
				НовоеПолеОбъекта.Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
				НовоеПолеОбъекта.Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
				НовоеПолеОбъекта.ДополнительныйТип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ДополнительныйТипЗначения);
				
				Ключ = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Ключ);				
				Если ВРег(Ключ) = "КЛЮЧ" Тогда
					ПротоОбъект.Ключи.Вставить(НовоеПолеОбъекта.Имя, НовоеПолеОбъекта.Значение);
				КонецЕсли;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		//Поля табличной части
		Если ДействиеТекущейСтроки = "ЧитаемТабЧасть" Тогда
			ИмяРеквизитаТЧ = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент, НомерСтроки, КолонкиМакета.Реквизит);
			Если Не ПустаяСтрока(ИмяРеквизитаТЧ) Тогда
				НовоеПолеТЧ = ОписаниеПолейТЧ.Добавить();
				НовоеПолеТЧ.Имя = ИмяРеквизитаТЧ;
				НовоеПолеТЧ.Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
				НовоеПолеТЧ.Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
				НовоеПолеТЧ.ДополнительныйТип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ДополнительныйТипЗначения);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		//Режимы объекта
		Если ДействиеТекущейСтроки = "ЧитаемРежимы" Тогда
			КодРежима = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Реквизит);
			Режим = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
			Если ВРег(КодРежима)="РЕЖИМ" Тогда
				Если ПротоОбъект.Режимы.Свойство(Режим) Тогда
					ПротоОбъект.Режимы[Режим] = Истина;
				КонецЕсли;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		//Дополнительные свойства
		Если ДействиеТекущейСтроки = "ЧитаемДопСвойства" Тогда
			ИмяДопСвойства = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент, НомерСтроки, КолонкиМакета.Реквизит);
			Если Не ПустаяСтрока(ИмяДопСвойства) Тогда
				НовоеПолеДопСвойств = ПротоОбъект.ДопСвойства.Добавить();
				НовоеПолеДопСвойств.Имя = ИмяДопСвойства;
				НовоеПолеДопСвойств.Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
				НовоеПолеДопСвойств.Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
				НовоеПолеДопСвойств.ДополнительныйТип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ДополнительныйТипЗначения);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Если ДействиеТекущейСтроки = "ЧитаемОбменДанными" Тогда
			ИмяОбменДанными = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент, НомерСтроки, КолонкиМакета.Реквизит);
			Если Не ПустаяСтрока(ИмяОбменДанными) Тогда
				НовоеПолеОбменаДанными = ПротоОбъект.ОбменДанными.Добавить();
				НовоеПолеОбменаДанными.Имя = ИмяОбменДанными;
				НовоеПолеОбменаДанными.Значение = ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения);
				НовоеПолеОбменаДанными.Режим = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Режим);
				НовоеПолеОбменаДанными.ДополнительныйТип = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.ДополнительныйТипЗначения);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецФункции

Функция ПроверитьКолонки(КолонкиМакета,ИмяКолонкиЗамещения)
	Для каждого Колонка Из КолонкиМакета Цикл
		Если Колонка.Значение = "0" Тогда
			Если Колонка.Ключ = "ДополнительныйТипЗначения" или Колонка.Ключ = "Ключ" Тогда
				//Это не обязательная колонка - может быть и не заполнена
			Иначе
				ВызватьИсключение "Неверно задан макет. Неверная колонка в первой строке. Не указана обязательная колонка с именем ["+Колонка.Ключ+"]";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если ЗначениеЗаполнено(ИмяКолонкиЗамещения) Тогда
		Если не КолонкиМакета.Свойство(ИмяКолонкиЗамещения) Тогда
			ВызватьИсключение "Указанное Имя колонки замещения ["+ИмяКолонкиЗамещения+"] не существует в макете.";
		КонецЕсли;
	КонецЕсли;
КонецФункции

Функция ПрочитатьЗначениеДанныхСтроки(ТабличныйДокумент,НомерСтроки,КолонкиМакета,ИмяКолонкиЗамещения)
	Значение = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета.Значение);
	Если ЗначениеЗаполнено(ИмяКолонкиЗамещения) Тогда
		ПриоритетноеЗначение = ПрочитатьЗначениеЯчейкиМакета(ТабличныйДокумент,НомерСтроки,КолонкиМакета[ИмяКолонкиЗамещения]);
		Если ЗначениеЗаполнено(ПриоритетноеЗначение) Тогда
			Значение = ПриоритетноеЗначение;
		КонецЕсли;
	КонецЕсли;
	Возврат Значение;
КонецФункции

Функция ПрочитатьЗначениеЯчейкиМакета(Макет,НомерСтроки,НомерКолонки);
	ТекстЯчейки = Неопределено;
	Если НомерСтроки<> "0" И НомерКолонки <> "0" Тогда
		ТекстЯчейки = Макет.Область("R" + НомерСтроки + "C" + НомерКолонки).Текст;
	КонецЕсли;
	Возврат ТекстЯчейки;
КонецФункции

Функция СоздатьСтруктуруОписанияОбъекта()
	СтруктураОписанияОбъекта = Новый Структура();
	СтруктураОписанияОбъекта.Вставить("Объект",Неопределено);
	СтруктураОписанияОбъекта.Вставить("Тип",Неопределено);
	СтруктураОписанияОбъекта.Вставить("Вид",Неопределено);
	СтруктураОписанияОбъекта.Вставить("ИмяПредопределенного",Неопределено);
	СтруктураОписанияОбъекта.Вставить("ИмяПеременной",Неопределено);
	СтруктураОписанияОбъекта.Вставить("Режимы",СоздатьСтруктуруРежимовОбъекта());
	СтруктураОписанияОбъекта.Вставить("Ключи", новый Структура);
	СтруктураОписанияОбъекта.Вставить("ПоляОбъекта",СоздатьТаблицуОписанияПолей());
	СтруктураОписанияОбъекта.Вставить("ТабличныеЧасти",Новый Структура);
	СтруктураОписанияОбъекта.Вставить("ДопСвойства",СоздатьТаблицуОписанияПолей());
	СтруктураОписанияОбъекта.Вставить("ОбменДанными",СоздатьТаблицуОписанияПолей());
	Возврат СтруктураОписанияОбъекта;
КонецФункции

Функция СоздатьСтруктуруРежимовОбъекта()
	Режимы = Новый Структура;
	Режимы.Вставить("Предопределенный",Ложь);
	Режимы.Вставить("СоздатьПоГуид",Ложь);
	Режимы.Вставить("ТолькоСоздание",Ложь);
	Режимы.Вставить("Проведение",Ложь);
	Режимы.Вставить("ОбменДанными",Ложь);
	Режимы.Вставить("Объект",Ложь);
	Режимы.Вставить("Группа",Ложь);
	Режимы.Вставить("ЭтотУзел",Ложь);
	Возврат Режимы;
КонецФункции


Функция СоздатьТаблицуОписанияПолей()
	тзОписаниеПолей = Новый ТаблицаЗначений;
	тзОписаниеПолей.Колонки.Добавить("Имя");
	тзОписаниеПолей.Колонки.Добавить("Значение");
	тзОписаниеПолей.Колонки.Добавить("Режим");
	тзОписаниеПолей.Колонки.Добавить("ДополнительныйТип");
	Возврат тзОписаниеПолей;
КонецФункции

Функция МенеджерыМетаданных()
	Менеджеры = Новый Структура;
	Менеджеры.Вставить("ПланОбмена",ПланыОбмена);
	Менеджеры.Вставить("Справочник",Справочники);
	Менеджеры.Вставить("Документ",Документы);
	Менеджеры.Вставить("БизнесПроцесс",БизнесПроцессы);
	Менеджеры.Вставить("Задача",Задачи);
	Менеджеры.Вставить("РегистрСведений",РегистрыСведений);
	Менеджеры.Вставить("РегистрНакопления",РегистрыНакопления);
	Менеджеры.Вставить("РегистрыБухгалтерии",РегистрыБухгалтерии);
	Менеджеры.Вставить("ПланВидовХарактеристик",ПланыВидовХарактеристик);
	Менеджеры.Вставить("ПользовательИБ",ПользователиИнформационнойБазы);
	Возврат Новый ФиксированнаяСтруктура(Менеджеры);
КонецФункции

Процедура ЗаменитьРежимыЗагрузки(ПротоДанные, РежимыЗагрузки)
	Если ЗначениеЗаполнено(РежимыЗагрузки) Тогда
		Для каждого КлючЗначение Из ПротоДанные Цикл
			ПротоОбъект = КлючЗначение.Значение;
			ЗаполнитьЗначенияСвойств(ПротоОбъект.Режимы, РежимыЗагрузки);
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

Функция СоздатьТестовыеДанныеПоПротоДанным(ПротоДанные)
	Данные = Новый Структура;
	МенеджерыМетаданных = МенеджерыМетаданных();
	Для каждого ПротоОбъект из ПротоДанные Цикл
		ОбъектСсылка = ПолучитьОбъект(ПротоДанные,ПротоОбъект.Значение);
		Данные.Вставить(ПротоОбъект.Значение.ИмяПеременной,ОбъектСсылка);
	КонецЦикла;
	Возврат Данные;
КонецФункции

Функция ПолучитьОбъект(ПротоДанные,ПротоОбъект)
	ОбъектСсылка = Неопределено;
	Если ПротоОбъект.Объект<>Неопределено Тогда
		Возврат ПротоОбъект.Объект;
	ИначеЕсли ПротоОбъект.Тип = "Справочник" Тогда
		ОбъектСсылка = СоздатьОбъект_Справочник(ПротоДанные,ПротоОбъект);
		
	ИначеЕсли ПротоОбъект.Тип = "Документ" Тогда
		ОбъектСсылка = СоздатьОбъект_Документ_или_БизнесПроцесс_или_Задача(Документы, ПротоДанные,ПротоОбъект);
		
	ИначеЕсли ПротоОбъект.Тип = "РегистрСведений" Тогда
		ОбъектСсылка = СоздатьОбъект_Регистр(РегистрыСведений, ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "РегистрНакопления" Тогда
		ОбъектСсылка = СоздатьОбъект_Регистр(РегистрыНакопления, ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "РегистрБухгалтерии" Тогда
		ОбъектСсылка = СоздатьОбъект_Регистр(РегистрыБухгалтерии, ПротоДанные,ПротоОбъект);
		
	ИначеЕсли ПротоОбъект.Тип = "ПользовательИБ" Тогда
		ОбъектСсылка = СоздатьОбъект_ПользовательИБ(ПротоДанные,ПротоОбъект);
		
	ИначеЕсли ПротоОбъект.Тип = "БизнесПроцесс" Тогда
		ОбъектСсылка = СоздатьОбъект_Документ_или_БизнесПроцесс_или_Задача(БизнесПроцессы, ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "Задача" Тогда
		ОбъектСсылка = СоздатьОбъект_Документ_или_БизнесПроцесс_или_Задача(Задачи, ПротоДанные,ПротоОбъект);
	ИначеЕсли ПротоОбъект.Тип = "ПланОбмена" Тогда
		ОбъектСсылка = СоздатьОбъект_УзелПланаОбмена(ПротоДанные,ПротоОбъект);
	КонецЕсли;
	ПротоОбъект.Объект = ОбъектСсылка;
	Возврат ОбъектСсылка;
КонецФункции

Функция СоздатьОбъект_УзелПланаОбмена(ПротоДанные, ПротоОбъект)
	ПланОбменаМенеджер = ПланыОбмена[ПротоОбъект.Вид];
	
	//Подготовим ПротоОбъект
	Объект = ПолучитьОбъектЕслиВПротоДанныеПереданаСсылка(ПланОбменаМенеджер, ПротоОбъект);
	Если Объект = Неопределено И ЗначениеЗаполнено(ПротоОбъект.Ключи) Тогда
		Объект = НайтиОбъектПоКлючам(ПротоОбъект, ПланОбменаМенеджер, ПротоОбъект.Ключи);
	КонецЕсли;

	Если ПротоОбъект.Режимы.ТолькоСоздание И Объект <> Неопределено Тогда
		Возврат ПротоОбъект.Объект;
	КонецЕсли;	
	
	//Создание узла плана обмена
	Если Объект = Неопределено Тогда
		Если ПротоОбъект.Режимы.ЭтотУзел Тогда
			Попытка
				Объект = ПланОбменаМенеджер.ЭтотУзел().ПолучитьОбъект();
			Исключение
				Ошибка = ОписаниеОшибки();
				ВызватьИсключение "ПланОбмена." + ПротоОбъект.Вид + " не удалось получить узел этой ИБ." + Символы.ПС + Ошибка;
			КонецПопытки;
		ИначеЕсли ПротоОбъект.Режимы.СоздатьПоГуид Тогда
			ВызватьИсключение "Устарело и больше не поддерживается: https://github.com/xDrivenDevelopment/xUnitFor1C/issues/332";
		Иначе
			Попытка
				Объект = ПланОбменаМенеджер.СоздатьУзел();
			Исключение
				Ошибка = ОписаниеОшибки();
				ВызватьИсключение "ПланОбмена." + ПротоОбъект.Вид + " не удалось создать новый узел." + Символы.ПС + Ошибка;
			КонецПопытки;
		КонецЕсли;
		
		Если Объект.ЭтоНовый() Тогда
			Если Не ЗначениеЗаполнено(ПротоОбъект.Объект) Тогда
				ПротоОбъект.Объект = ПланОбменаМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор);
			КонецЕсли;
			Объект.УстановитьСсылкуНового(ПротоОбъект.Объект);
		Иначе
			ПротоОбъект.Объект = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	//Заполняем реквизиты узла плана обмена
	НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, Объект.Метаданные());
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные, стрПоле, НаборМдРеквизитов);
	КонецЦикла;
	
	Для каждого ТабЧасть из ПротоОбъект.ТабличныеЧасти Цикл
		Для каждого СтрокаТабЧасти Из ТабЧасть.Значение Цикл
			СтрокаТабЧастиОбъекта = Объект[ТабЧасть.Ключ].Добавить();
			объектМетаданныеТабличнаяЧасть = Объект.Метаданные().ТабличныеЧасти[ТабЧасть.Ключ];
			НаборМдРеквизитовТЧ = объектМетаданныеТабличнаяЧасть.Реквизиты;
			Для каждого стрПоле Из СтрокаТабЧасти Цикл
				СтрокаТабЧастиОбъекта[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные, стрПоле, НаборМдРеквизитовТЧ);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	//Служебные поля и значения
	Если Не ЗначениеЗаполнено(Объект.Код) тогда
		Объект.УстановитьНовыйКод();
	КонецЕсли;
	
	ЗаполнитьДополнительныеСвойства(Объект, ПротоДанные, ПротоОбъект);
	
	ПредставлениеМетаданного = "узел плана обмена";
	Результат = ЗаписатьОбъектПриНеобходимости(Объект, ПротоОбъект, ПредставлениеМетаданного, Истина);
	
	Возврат Результат;
КонецФункции

Функция СоздатьОбъект_Справочник(ПротоДанные,ПротоОбъект)
	СпрМенеджер = Справочники[ПротоОбъект.Вид];
	
	//Подготовим ПротоОбъект
	стрПолеЭтоГруппа = ПротоОбъект.ПоляОбъекта.Найти("ЭтоГруппа","Имя");
	Если стрПолеЭтоГруппа<>Неопределено Тогда
		ПротоОбъект.Режимы.Группа = Булево(стрПолеЭтоГруппа.Значение);
		ПротоОбъект.ПоляОбъекта.Удалить(стрПолеЭтоГруппа);
	КонецЕсли;

	Объект = ПолучитьОбъектЕслиВПротоДанныеПереданаСсылка(СпрМенеджер, ПротоОбъект);
	Если Объект=Неопределено И ЗначениеЗаполнено(ПротоОбъект.Ключи) Тогда
		Объект = НайтиОбъектПоКлючам(ПротоОбъект, СпрМенеджер, ПротоОбъект.Ключи);
	КонецЕсли;

	Если ПротоОбъект.Режимы.ТолькоСоздание И Объект<>Неопределено Тогда
		Возврат ПротоОбъект.Объект;
	КонецЕсли;	
	
	//Создание объекта справочника
	Если Объект=Неопределено Тогда
		Если ПротоОбъект.Режимы.Предопределенный Тогда
			Попытка
				Объект = СпрМенеджер[ПротоОбъект.ИмяПредопределенного].ПолучитьОбъект();
			Исключение
				Ошибка = ОписаниеОшибки();
				ВызватьИсключение "Справочник."+ПротоОбъект.Вид+" не удалось найти предопределенный элемент/группу ["+ПротоОбъект.ИмяПредопределенного+"]."+Символы.ПС+Ошибка;
			КонецПопытки;
		ИначеЕсли ПротоОбъект.Режимы.СоздатьПоГуид Тогда
			ВызватьИсключение "Устарело и больше не поддерживается: https://github.com/xDrivenDevelopment/xUnitFor1C/issues/332";
		ИначеЕсли ПротоОбъект.Режимы.Группа Тогда
			Попытка
				Объект = СпрМенеджер.СоздатьГруппу();
			Исключение
				Ошибка = ОписаниеОшибки();
				ВызватьИсключение "Справочник."+ПротоОбъект.Вид+" не удалось создать новую группу."+Символы.ПС+Ошибка;
			КонецПопытки;
		Иначе
			Попытка
				Объект = СпрМенеджер.СоздатьЭлемент();
			Исключение
				Ошибка = ОписаниеОшибки();
				ВызватьИсключение "Справочник."+ПротоОбъект.Вид+" не удалось создать новый элемент."+Символы.ПС+Ошибка;
			КонецПопытки;
		КонецЕсли;
		
		Если Объект.ЭтоНовый() Тогда
			Если Не ЗначениеЗаполнено(ПротоОбъект.Объект) Тогда
				ПротоОбъект.Объект = СпрМенеджер.ПолучитьСсылку(Новый УникальныйИдентификатор);
			КонецЕсли;
			Объект.УстановитьСсылкуНового(ПротоОбъект.Объект);
		Иначе
			ПротоОбъект.Объект = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	//Заполняем реквизиты справочника
	НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, Объект.Метаданные());
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
	КонецЦикла;
	
	Для каждого мдТабЧасть из Объект.Метаданные().ТабличныеЧасти Цикл
		ЭтоРежимГруппа = ПротоОбъект.Режимы.Группа;
		Если (ЭтоРежимГруппа И мдТабЧасть.Использование<>Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			Или (Не ЭтоРежимГруппа И мдТабЧасть.Использование<>Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы) Тогда
			
				Объект[мдТабЧасть.Имя].Очистить();
		КонецЕсли;
		 
	КонецЦикла;
	Для каждого ТабЧасть из ПротоОбъект.ТабличныеЧасти Цикл
		Для каждого СтрокаТабЧасти Из ТабЧасть.Значение Цикл
			СтрокаТабЧастиОбъекта = Объект[ТабЧасть.Ключ].Добавить();
			объектМетаданныеТабличнаяЧасть = Объект.Метаданные().ТабличныеЧасти[ТабЧасть.Ключ];
			НаборМдРеквизитовТЧ = объектМетаданныеТабличнаяЧасть.Реквизиты;
			Для каждого стрПоле Из СтрокаТабЧасти Цикл
				СтрокаТабЧастиОбъекта[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитовТЧ);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	//Служебные поля и значения
	Если Не ЗначениеЗаполнено(Объект.Код) тогда
		Объект.УстановитьНовыйКод();
	КонецЕсли;
	
	ЗаполнитьОбменДанными(Объект, ПротоДанные, ПротоОбъект);
	ЗаполнитьДополнительныеСвойства(Объект, ПротоДанные, ПротоОбъект);
	
	ПредставлениеМетаданного = "справочника";
	Результат = ЗаписатьОбъектПриНеобходимости(Объект, ПротоОбъект, ПредставлениеМетаданного, Истина);
	
	Возврат Результат;
КонецФункции

Функция НайтиОбъектПоКлючам(ПротоОбъект, МенеджерОбъекта, СтруктураРеквизитовКлючей)
	Рез = Неопределено;
	МдОбъект = МенеджерОбъекта.ПустаяСсылка().Метаданные();
	МдПолноеИмя = МдОбъект.ПолноеИмя();
	МдРеквизиты = МдОбъект.Реквизиты;
	МдСтандартныеРеквизиты = МдОбъект.СтандартныеРеквизиты;
	
	ТекстЗапроса = "Выбрать Первые 1 Т.Ссылка Из "+МдПолноеИмя+" КАК Т Где Истина ";
	Запрос = Новый Запрос;
	Для каждого КлючЗначение Из СтруктураРеквизитовКлючей Цикл
		ИмяРеквизита = КлючЗначение.Ключ;
		ЗначениеРеквизита = КлючЗначение.Значение;
		Если МдРеквизиты.Найти(ИмяРеквизита) = Неопределено и Не ЕстьСтандартныйРеквизит(МдСтандартныеРеквизиты, ИмяРеквизита) Тогда
			ВызватьИсключение "В метаданных "+МдПолноеИмя+" не найден реквизит-ключ <"+ИмяРеквизита+">. Ошибка в макете данных";
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + " И "+ИмяРеквизита+" = &"+ИмяРеквизита;
		Запрос.УстановитьПараметр(ИмяРеквизита, ЗначениеРеквизита);		
	КонецЦикла;
	Запрос.Текст = ТекстЗапроса;
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		ПротоОбъект.Объект = Выборка.Ссылка;
		Рез = ПротоОбъект.Объект.ПолучитьОбъект();
	КонецЕсли;
	
	Возврат Рез;
КонецФункции

Функция ЕстьСтандартныйРеквизит(МдСтандартныеРеквизиты, ИмяРеквизита)
	Для каждого РеквизитМд Из МдСтандартныеРеквизиты Цикл
		Если РеквизитМд.Имя = ИмяРеквизита Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция СоздатьОбъект_Документ_или_БизнесПроцесс_или_Задача(МенеджерВсехВидов, ПротоДанные,ПротоОбъект)
	ЭтоДокумент = МенеджерВсехВидов = Документы;
	ЭтоБизнесПроцесс = МенеджерВсехВидов = БизнесПроцессы;
	ЭтоЗадача = МенеджерВсехВидов = Задачи;
	
	Если ЭтоДокумент Тогда
		ПредставлениеМенеджера = "Документы";
	ИначеЕсли ЭтоБизнесПроцесс Тогда
		ПредставлениеМенеджера = "БизнесПроцессы";
	ИначеЕсли ЭтоЗадача Тогда
		ПредставлениеМенеджера = "Задачи";
	Иначе
		ВызватьИсключение "Требуется документ, бизнес-процесс или задача. Неизвестный менеджер "+ПротоОбъект.Тип+"."+ПротоОбъект.Вид+" . Переменная "+ПротоОбъект.ИмяПеременной;
	КонецЕсли;
	
	МенеджерОбъекта = МенеджерВсехВидов[ПротоОбъект.Вид];
	Объект = ПолучитьОбъектЕслиВПротоДанныеПереданаСсылка(МенеджерОбъекта, ПротоОбъект);
	Если Объект=Неопределено И ЗначениеЗаполнено(ПротоОбъект.Ключи) Тогда
		Объект = НайтиОбъектПоКлючам(ПротоОбъект, МенеджерОбъекта, ПротоОбъект.Ключи);
	КонецЕсли;
	
	Если ПротоОбъект.Режимы.ТолькоСоздание И Объект<>Неопределено Тогда
		Возврат ПротоОбъект.Объект;
	КонецЕсли;
	
	//Создание объекта
	Если Объект = Неопределено Тогда
		Попытка
			Если ЭтоДокумент Тогда
				Объект = МенеджерОбъекта.СоздатьДокумент();
			ИначеЕсли ЭтоБизнесПроцесс Тогда
				Объект = МенеджерОбъекта.СоздатьБизнесПроцесс();
			ИначеЕсли ЭтоЗадача Тогда
				Объект = МенеджерОбъекта.СоздатьЗадачу();
			КонецЕсли;
		Исключение
			Ошибка = ОписаниеОшибки();
			ВызватьИсключение ПредставлениеМенеджера+"."+ПротоОбъект.Вид+" не удалось создать новый элемент."+Символы.ПС+Ошибка;
		КонецПопытки;
	
		//Установка ссылки
		Если Объект.ЭтоНовый() Тогда
			Если Не ЗначениеЗаполнено(ПротоОбъект.Объект) Тогда
				ПротоОбъект.Объект = МенеджерОбъекта.ПолучитьСсылку(Новый УникальныйИдентификатор);
			КонецЕсли;
			Объект.УстановитьСсылкуНового(ПротоОбъект.Объект);
		КонецЕсли;
	КонецЕсли;
	
	//Заполняем реквизиты
	НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, Объект.Метаданные());
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
	КонецЦикла;
	
	Для каждого мдТабЧасть из Объект.Метаданные().ТабличныеЧасти Цикл
		Объект[мдТабЧасть.Имя].Очистить();
	КонецЦикла;
	Для каждого ТабЧасть из ПротоОбъект.ТабличныеЧасти Цикл
		Для каждого СтрокаТабЧасти Из ТабЧасть.Значение Цикл
			СтрокаТабЧастиОбъекта = Объект[ТабЧасть.Ключ].Добавить();
			объектМетаданныеТабличнаяЧасть = Объект.Метаданные().ТабличныеЧасти[ТабЧасть.Ключ];
			НаборМдРеквизитовТЧ = объектМетаданныеТабличнаяЧасть.Реквизиты;
			Для каждого стрПоле Из СтрокаТабЧасти Цикл
				СтрокаТабЧастиОбъекта[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитовТЧ);
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	//Служебные поля и значения
	Если Не ЗначениеЗаполнено(Объект.Дата) Тогда
		Объект.Дата = ТекущаяДата();
	КонецЕсли;			
	Если Не ЗначениеЗаполнено(Объект.Номер) тогда
		Объект.УстановитьНовыйНомер();
	КонецЕсли;
	
	ЗаполнитьОбменДанными(Объект, ПротоДанные, ПротоОбъект);
	ЗаполнитьДополнительныеСвойства(Объект, ПротоДанные, ПротоОбъект);
	
	РежимЗаписи = Неопределено;
	Если ЭтоДокумент И Не ПротоОбъект.Режимы.Объект Тогда
		РежимЗаписи = РежимЗаписиДокумента.Запись;
		Если ПротоОбъект.Режимы.Проведение Тогда
			РежимЗаписи = РежимЗаписиДокумента.Проведение;
		КонецЕсли;
	КонецЕсли;
	Результат = ЗаписатьОбъектПриНеобходимости(Объект, ПротоОбъект, ПредставлениеМенеджера, Истина, РежимЗаписи);
	
	Возврат Результат;
КонецФункции

Функция СоздатьОбъект_Регистр(МенеджерРегистра, ПротоДанные,ПротоОбъект)
	ЭтоРегистрСведения = МенеджерРегистра = РегистрыСведений;
	ЭтоРегистрБухгалтерии = МенеджерРегистра = РегистрыБухгалтерии;
	ЭтоРегистрНакопления = МенеджерРегистра = РегистрыНакопления;
	
	Если ЭтоРегистрСведения Тогда
		ПредставлениеМдМенеджераРегистра = "РегистрыСведения";
	ИначеЕсли ЭтоРегистрБухгалтерии Тогда
		ПредставлениеМдМенеджераРегистра = "РегистрыБухгалтерии";
	ИначеЕсли ЭтоРегистрНакопления Тогда
		ПредставлениеМдМенеджераРегистра = "РегистрыНакопления";
	Иначе
		ВызватьИсключение "Неизвестный менеджер регистра "+ПротоОбъект.Тип+"."+ПротоОбъект.Вид+" . Переменная "+ПротоОбъект.ИмяПеременной;
	КонецЕсли;
	Если ЗначениеЗаполнено(ПротоОбъект.Ключи) Тогда
		ВызватьИсключение "Работа с ключами для "+ПредставлениеМдМенеджераРегистра+" пока не поддерживается";
	КонецЕсли;
	
	//Создание объекта
	ПротоНаборЗаписей = Неопределено;
	Если ПротоОбъект.ТабличныеЧасти.Свойство("Запись",ПротоНаборЗаписей) Тогда
		Попытка
			Объект = МенеджерРегистра[ПротоОбъект.Вид].СоздатьНаборЗаписей();
		Исключение
			Ошибка = ОписаниеОшибки();
			ВызватьИсключение ПредставлениеМдМенеджераРегистра+"."+ПротоОбъект.Вид+" не удалось создать новый НаборЗаписей."+Символы.ПС+Ошибка;
		КонецПопытки;
		
		МетаданныеНабора = Объект.Метаданные();
		НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, МетаданныеНабора);
				
		РегистрСведенийПодчиненРегистратору = Истина;
		Если ЭтоРегистрСведения Тогда
			РегистрСведенийПодчиненРегистратору = МетаданныеНабора.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору;
			
		ИначеЕсли ЭтоРегистрБухгалтерии Тогда
			НаборВидовСубконто = Новый Структура;

			ПостфиксыСчетов = Новый Массив;
			Если МетаданныеНабора.Корреспонденция Тогда
				ПостфиксыСчетов.Добавить("Дт");
				ПостфиксыСчетов.Добавить("Кт");
			Иначе
				ПостфиксыСчетов.Добавить("");
			КонецЕсли;
			Для каждого ПостфиксСчета Из ПостфиксыСчетов Цикл
				НаборМдРеквизитов.Вставить("Счет"+ПостфиксСчета, МетаданныеНабора.ПланСчетов);
				Для НомерВидаСубконто = 1 По МетаданныеНабора.ПланСчетов.МаксКоличествоСубконто Цикл
					ОписаниеСубконто = Новый Структура("ИмяРеквизитаСчет,ИмяРеквизитаСубконто,НомерВидаСубконто", "Счет"+ПостфиксСчета, "Субконто"+ПостфиксСчета, НомерВидаСубконто-1);
					НаборВидовСубконто.Вставить("Субконто"+ПостфиксСчета+НомерВидаСубконто, ОписаниеСубконто);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		
		Для каждого СтрокаЗаписи Из ПротоНаборЗаписей Цикл
			ЗаписьНабора = Объект.Добавить();
			Для каждого стрПоле Из СтрокаЗаписи Цикл
				ЗначениеПоля = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);

				ОписаниеСубконто = Неопределено;
				Если ЭтоРегистрБухгалтерии И НаборВидовСубконто.Свойство(стрПоле.Имя, ОписаниеСубконто) Тогда
					ВидСубконто = ЗаписьНабора[ОписаниеСубконто.ИмяРеквизитаСчет].ВидыСубконто[ОписаниеСубконто.НомерВидаСубконто].ВидСубконто;
					ЗаписьНабора[ОписаниеСубконто.ИмяРеквизитаСубконто].Вставить(ВидСубконто, ЗначениеПоля);
				Иначе
					ЗаписьНабора[стрПоле.Имя] = ЗначениеПоля;
				КонецЕсли;
			КонецЦикла;
			
			Если РегистрСведенийПодчиненРегистратору Тогда
				ПроверитьЗаполненность(ЗаписьНабора.Регистратор, "Не задан регистратор для записей регистра "+ПредставлениеМдМенеджераРегистра+". Переменная "+ПротоОбъект.ИмяПеременной);
				Если НЕ ЗначениеЗаполнено(ЗаписьНабора.Период) Тогда
					ЗаписьНабора.Период = ЗаписьНабора.Регистратор.Дата;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		ЗаписьНабора = Объект[0];
		Если РегистрСведенийПодчиненРегистратору Тогда
			Объект.Отбор.Регистратор.Установить(ЗаписьНабора.Регистратор);
		Иначе
			Для каждого МетаИзмерение Из МетаданныеНабора.Измерения Цикл
				ИмяИзмерения = МетаИзмерение.Имя;
				Если Объект.Отбор.Найти(ИмяИзмерения)	<> Неопределено Тогда
					Объект.Отбор[ИмяИзмерения].Установить(ЗаписьНабора[ИмяИзмерения]);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		ЗаполнитьОбменДанными(Объект, ПротоДанные, ПротоОбъект);
		ЗаполнитьДополнительныеСвойства(Объект, ПротоДанные, ПротоОбъект);
		
	ИначеЕсли ЭтоРегистрСведения Тогда
		Попытка
			Объект = РегистрыСведений[ПротоОбъект.Вид].СоздатьМенеджерЗаписи();
		Исключение
			Ошибка = ОписаниеОшибки();
			ВызватьИсключение ПредставлениеМдМенеджераРегистра+"."+ПротоОбъект.Вид+" не удалось создать новый набор записей"+Символы.ПС+Ошибка;
		КонецПопытки;
		
		НаборМдРеквизитов = НаборРеквизитовМетаданных(ПротоОбъект.Тип, РегистрыСведений[ПротоОбъект.Вид].СоздатьНаборЗаписей().Метаданные());
		Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
			Объект[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов);
		КонецЦикла;
	Иначе
		ВызватьИсключение ПредставлениеМдМенеджераРегистра+"."+ПротоОбъект.Вид+" в макете нет записей для регистра "+ПредставлениеМдМенеджераРегистра;
	КонецЕсли;
		
	ПредставлениеМетаданного = "набора записей "+ПредставлениеМдМенеджераРегистра;
	ЗаписатьОбъектПриНеобходимости(Объект, ПротоОбъект, ПредставлениеМетаданного, Ложь);
	
	Возврат Объект;
КонецФункции

Функция СоздатьОбъект_ПользовательИБ(ПротоДанные,ПротоОбъект)
	Если ЗначениеЗаполнено(ПротоОбъект.Ключи) Тогда
		ВызватьИсключение "Работа с ключами при создании пользователя ИБ пока не поддерживается";
	КонецЕсли;
	Объект = ПользователиИнформационнойБазы.СоздатьПользователя();
	
	параметрыПользователя = Новый Структура;
	параметрыПользователя.Вставить("Имя", "");
	параметрыПользователя.Вставить("ПолноеИмя", "");
	параметрыПользователя.Вставить("АутентификацияСтандартная", Истина);
	параметрыПользователя.Вставить("АутентификацияОС", Ложь);
	параметрыПользователя.Вставить("ПользовательОС", "");
	параметрыПользователя.Вставить("ОсновнойИнтерфейс", ""); //Метаданные.Интерфейсы.Администратор);
	параметрыПользователя.Вставить("Пароль", "пароль");
	параметрыПользователя.Вставить("ПоказыватьВСпискеВыбора", Истина);
	параметрыПользователя.Вставить("РежимЗапуска", РежимЗапускаКлиентскогоПриложения.Авто);
	параметрыПользователя.Вставить("Язык", Метаданные.Языки.Русский);
	массивРолей = Новый Массив;
	параметрыПользователя.Вставить("Роли", массивРолей);
	
	//Заполняем реквизиты справочника
	Для каждого стрПоле Из ПротоОбъект.ПоляОбъекта Цикл
		параметрыПользователя[стрПоле.Имя] = ПолучитьЗначениеПоля(ПротоДанные,стрПоле,Неопределено);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Объект, параметрыПользователя,, "ОсновнойИнтерфейс,РежимЗапуска");
	
	ПротоНаборРолей = Неопределено;
	Если ПротоОбъект.ТабличныеЧасти.Свойство("Роли",ПротоНаборРолей) Тогда
		Для каждого СтрокаРоли Из ПротоНаборРолей Цикл
			Для каждого стрПоле Из СтрокаРоли Цикл
				Роль = Метаданные.Роли.Найти(ПолучитьЗначениеПоля(ПротоДанные,стрПоле,Неопределено));
				параметрыПользователя.Роли.Добавить(Роль);
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	НашлиРежимЗапуска = Ложь;
	Для каждого ЗначениеРежимаЗапуска Из РежимЗапускаКлиентскогоПриложения Цикл
		Если НРег(""+ЗначениеРежимаЗапуска) = НРег(параметрыПользователя.РежимЗапуска) Тогда
			НашлиРежимЗапуска = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если НашлиРежимЗапуска Тогда
		Объект.РежимЗапуска = ЗначениеРежимаЗапуска;
	Иначе
		ВызватьИсключение "Не нашли режим запуска <"+параметрыПользователя.РежимЗапуска+">. Возможно, нужно указать с пробелом, например, ""Управляемое приложение""";
	КонецЕсли;
	
	Если ЗначениеЗаполнено(параметрыПользователя.ОсновнойИнтерфейс) Тогда
		Объект.ОсновнойИнтерфейс = Метаданные.Интерфейсы.Найти(параметрыПользователя.ОсновнойИнтерфейс);
	КонецЕсли;
	Для каждого роль Из параметрыПользователя.Роли Цикл
		Объект.Роли.Добавить(роль);
	КонецЦикла;
	
	ПредставлениеМетаданного = "пользователя ИБ ";
	ЗаписатьОбъектПриНеобходимости(Объект, ПротоОбъект, ПредставлениеМетаданного, Ложь);
	
	Возврат Объект;
КонецФункции

Функция ПолучитьОбъектЕслиВПротоДанныеПереданаСсылка(МенеджерОбъекта, ПротоОбъект)
	Перем Объект;
	стрПолеСсылка = ПротоОбъект.ПоляОбъекта.Найти("Ссылка","Имя");
	Если стрПолеСсылка<>Неопределено Тогда
		ПротоОбъект.Объект = МенеджерОбъекта.ПолучитьСсылку(Новый УникальныйИдентификатор(стрПолеСсылка.Значение));
		ПротоОбъект.ПоляОбъекта.Удалить(стрПолеСсылка);
		Объект = ПротоОбъект.Объект.ПолучитьОбъект();
	КонецЕсли;
	Возврат Объект;
КонецФункции

Процедура ЗаполнитьОбменДанными(Объект, ПротоДанные, ПротоОбъект)
	Объект.ОбменДанными.Загрузка = ПротоОбъект.Режимы.ОбменДанными;
	
	//Дополнительные Свойства
	Для каждого стрДопСвойство Из ПротоОбъект.ДопСвойства Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ДополнительныеСвойства.Вставить(стрДопСвойство.Имя,Значение);
	КонецЦикла;
	Для каждого стрДопСвойство Из ПротоОбъект.ОбменДанными Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ОбменДанными[стрДопСвойство.Имя] = Значение;
	КонецЦикла;
КонецПроцедуры

Функция ЗаписатьОбъектПриНеобходимости(Объект, ПротоОбъект, ПредставлениеМетаданного, ЭтоСсылочныйОбъект, РежимЗаписи = Неопределено)
	Перем Результат;
	Если Не ПротоОбъект.Режимы.Объект Тогда
		Попытка
			Если РежимЗаписи = Неопределено Тогда
				Объект.Записать();
			Иначе
				Объект.Записать(РежимЗаписи);
			КонецЕсли;
			Если ЭтоСсылочныйОбъект Тогда
				Результат = Объект.Ссылка;
			КонецЕсли;
		Исключение
			Ошибка = ОписаниеОшибки();
			Ошибка = "Ошибка записи "+ПредставлениеМетаданного+" "+ПротоОбъект.Вид+", переменная "+ПротоОбъект.ИмяПеременной + Символы.ПС + Ошибка;
			ВызватьИсключение Ошибка;
		КонецПопытки;
	ИначеЕсли ЭтоСсылочныйОбъект Тогда
		Результат = Объект;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Процедура ЗаполнитьДополнительныеСвойства(Объект, ПротоДанные, ПротоОбъект)
	Для каждого стрДопСвойство Из ПротоОбъект.ДопСвойства Цикл
		Значение = ПолучитьЗначениеПоля(ПротоДанные,стрДопСвойство,Неопределено);
		Объект.ДополнительныеСвойства.Вставить(стрДопСвойство.Имя,Значение);
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьЗначениеПоля(ПротоДанные,стрПоле,НаборМдРеквизитов)
	Значение = Неопределено;
	Если ПустаяСтрока(стрПоле.Режим) Тогда
		Если ЗначениеЗаполнено(стрПоле.ДополнительныйТип) Тогда
			ТипЗначения = Новый ОписаниеТипов(стрПоле.ДополнительныйТип);
			Значение = ТипЗначения.ПривестиЗначение(стрПоле.Значение);
		Иначе
			Значение = стрПоле.Значение;
		КонецЕсли;
	ИначеЕсли ВРег(стрПоле.Режим) = "ПЕРЕМ" Тогда
		Значение = ПротоДанные[стрПоле.Значение].Объект;
		Если Не ЗначениеЗаполнено(Значение) Тогда
			Значение = ПолучитьОбъект(ПротоДанные, ПротоДанные[стрПоле.Значение]);
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(Значение) Тогда
			ВызватьИсключение "ЗначениеНеНайдено: Реквизит <"+стрПоле.Имя+">: Искали значение <"+стрПоле.Значение+">, но не нашли!";
		КонецЕсли;
	ИначеЕсли ВРег(стрПоле.Режим) = "ТЕКУЩАЯДАТА" Тогда
		Значение = ТекущаяДата();
	ИначеЕсли ВРег(стрПоле.Режим) = "ВЫРАЖЕНИЕ" Тогда 
		Значение = Вычислить(стрПоле.Значение);
	Иначе
		Значение = ВычислитьЗначениеПоТипуПоля(НаборМдРеквизитов,стрПоле);
	КонецЕсли;
	Возврат Значение;
КонецФункции

Функция ВычислитьЗначениеПоТипуПоля(НаборМдРеквизитов,стрПоле)
	Значение = Неопределено;
	Режим = ВРег(стрПоле.Режим);
	
	Попытка
		Если НаборМдРеквизитов = Неопределено Тогда
			Если НЕ ЗначениеЗаполнено(стрПоле.ДополнительныйТип) Тогда
				ВызватьИсключение "Не указан дополнительный тип значения";
			КонецЕсли;
			МетаданныеРеквизита = Неопределено;
		Иначе
			МетаданныеРеквизита = НаборМдРеквизитов[стрПоле.Имя];
		КонецЕсли; 
		УжеВычислилиЗначение = Ложь;
		ЕстьМетаданныеРеквизита = Ложь;
		Если Режим = "ГУИД" И МетаданныеРеквизита <> Неопределено И МетаданныеРеквизита.Тип.СодержитТип(Тип("УникальныйИдентификатор")) Тогда
			Значение = Новый УникальныйИдентификатор(стрПоле.Значение);
			УжеВычислилиЗначение = Истина;
		Иначе
			
			Если ЗначениеЗаполнено(стрПоле.ДополнительныйТип) Тогда
				ТипЗначения = Новый ОписаниеТипов(стрПоле.ДополнительныйТип);
			Иначе
				Если Метаданные.ПланыСчетов.Найти(МетаданныеРеквизита) <> Неопределено Тогда
					ТипЗначения = Новый ОписаниеТипов("ПланСчетовСсылка."+МетаданныеРеквизита.Имя);
				Иначе
					ТипЗначения = МетаданныеРеквизита.Тип;
				КонецЕсли;
			КонецЕсли;
			ЗначениеПоУмолчанию = ТипЗначения.ПривестиЗначение();
			Попытка
				МетаданныеТипаРеквизита = ЗначениеПоУмолчанию.Метаданные();
				ЕстьМетаданныеРеквизита = Истина;
			Исключение
			КонецПопытки;
			
			Если Не ЕстьМетаданныеРеквизита И Режим = "ПРЕДОПРЕДЕЛЕННЫЙ" Тогда
				Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип( ТипЗначения.Типы()[0] ) Тогда
					Значение = ПолучитьЗначениеТочкиБизнесПроцесса(стрПоле.Значение);
					УжеВычислилиЗначение = Истина;
				Иначе
					Значение = Неопределено;
					СтрокаДляВыполнения = "Значение = "+ТипЗначения+"["""+стрПоле.Значение+"""];";
					Выполнить(СтрокаДляВыполнения);
					УжеВычислилиЗначение = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если Не УжеВычислилиЗначение и ЕстьМетаданныеРеквизита Тогда
			ПолноеИмяТипаРеквизита = МетаданныеТипаРеквизита.ПолноеИмя();
			
			Если Найти(ПолноеИмяТипаРеквизита, "Справочник") = 1 Тогда
				менеджерОбъекта = Справочники[МетаданныеТипаРеквизита.Имя];
			ИначеЕсли Найти(ПолноеИмяТипаРеквизита, "Документ") = 1 Тогда
				менеджерОбъекта = Документы[МетаданныеТипаРеквизита.Имя];
			ИначеЕсли Найти(ПолноеИмяТипаРеквизита, "Перечисление") = 1 Тогда
				менеджерОбъекта = Перечисления[МетаданныеТипаРеквизита.Имя];
			ИначеЕсли Найти(ПолноеИмяТипаРеквизита, "ПланСчетов") = 1 Тогда
				менеджерОбъекта = ПланыСчетов[МетаданныеТипаРеквизита.Имя];
			ИначеЕсли Найти(ПолноеИмяТипаРеквизита, "ПланВидовХарактеристик") = 1 Тогда
				менеджерОбъекта = ПланыВидовХарактеристик[МетаданныеТипаРеквизита.Имя];
			КонецЕсли;
			ПроверитьНеРавенство(менеджерОбъекта, Неопределено, "не найден менеджерОбъекта");
			
			Если Режим = "ПРЕДОПРЕДЕЛЕННЫЙ" Тогда
				//Значение = менеджерОбъекта[стрПоле.Значение];
				Если ЗначениеЗаполнено(стрПоле.Значение) Тогда
					Значение = менеджерОбъекта[стрПоле.Значение];
				Иначе
					Значение = менеджерОбъекта.ПустаяСсылка();
				КонецЕсли;
			ИначеЕсли Режим = "КОД" Тогда
				Значение = менеджерОбъекта.НайтиПоКоду(стрПоле.Значение);
			ИначеЕсли Режим = "НОМЕР" Тогда
				Значение = НайтиБлижайшийДокументПоНомеру(МетаданныеТипаРеквизита, стрПоле.Значение);
			ИначеЕсли Режим = "НАИМЕНОВАНИЕ" Тогда
				Значение = менеджерОбъекта.НайтиПоНаименованию(стрПоле.Значение, Истина);
			ИначеЕсли Режим = "ГУИД" Тогда
				Значение = менеджерОбъекта.ПолучитьСсылку(Новый УникальныйИдентификатор(стрПоле.Значение));
			Иначе
				ВызватьИсключение "НеверныйРежимПоиска: Не поддерживаемый режим поиска. Реквизит <"+стрПоле.Имя+">: Искали значение <"+стрПоле.Значение+">";
			КонецЕсли;
			
			Если ЗначениеЗаполнено(стрПоле.Значение) И Не ЗначениеЗаполнено(Значение) Тогда //Если Не ЗначениеЗаполнено(Значение) Тогда
				ВызватьИсключение "ЗначениеНеНайдено: Реквизит <"+стрПоле.Имя+">: Искали значение <"+стрПоле.Значение+">, но не нашли!";
			КонецЕсли;
		КонецЕсли;
	Исключение
		ошибка = ОписаниеОшибки();
		Если Найти(ошибка, "НеверныйРежимПоиска") = 0 Тогда
			ошибка = "ОшибкаПоиска:  Реквизит <"+стрПоле.Имя+">: Искали значение <"+стрПоле.Значение+"> " + ошибка;
		КонецЕсли;
		ВызватьИсключение ошибка;
	КонецПопытки;
		
	Возврат Значение;
КонецФункции

Функция СоздатьПользователяИБ(параметры) Экспорт
	НовыйПользователь = ПользователиИнформационнойБазы.СоздатьПользователя();

	ЗаполнитьЗначенияСвойств(НовыйПользователь, параметры,, "ОсновнойИнтерфейс");
	Если ЗначениеЗаполнено(параметры.ОсновнойИнтерфейс) Тогда
		НовыйПользователь.ОсновнойИнтерфейс = Метаданные.Интерфейсы.Найти(параметры.ОсновнойИнтерфейс);
	КонецЕсли;
	Для каждого роль Из параметры.Роли Цикл
		НовыйПользователь.Роли.Добавить(роль);
	КонецЦикла;

	НовыйПользователь.Записать();  
	Возврат НовыйПользователь;
КонецФункции

Функция КолонкиМакетаДанных()
	КолонкиМакета = Новый Структура();
	СтрокаЗеро = "0";
	КолонкиМакета.Вставить("Тип", СтрокаЗеро);
	КолонкиМакета.Вставить("Вид", СтрокаЗеро);
	КолонкиМакета.Вставить("ИмяПеременной", СтрокаЗеро);
	КолонкиМакета.Вставить("ТЧ", СтрокаЗеро);
	КолонкиМакета.Вставить("Реквизит", СтрокаЗеро);
	КолонкиМакета.Вставить("Значение", СтрокаЗеро);
	КолонкиМакета.Вставить("Режим", СтрокаЗеро);
	КолонкиМакета.Вставить("ДополнительныйТипЗначения", СтрокаЗеро);
	КолонкиМакета.Вставить("Ключ", СтрокаЗеро);
	Возврат КолонкиМакета;
КонецФункции

Функция ПолучитьЗначениеТочкиБизнесПроцесса(Значение_Строкой)
	Значение = Неопределено;
	Для каждого БизнесПроцессМенеджер из БизнесПроцессы Цикл
		ТочкиМаршрута = БизнесПроцессМенеджер.ТочкиМаршрута;
		Для каждого ТочкаМаршрута Из ТочкиМаршрута Цикл
			Если ВРег(ТочкаМаршрута.Имя) = ВРег(Значение_Строкой) Тогда
				Значение = ТочкаМаршрута;
				Возврат Значение;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Возврат Значение;
КонецФункции

Функция НайтиБлижайшийДокументПоНомеру(МетаданныеДокумента, Значение_Строкой)

	ТекстЗапроса = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Доки.Ссылка,
		|	Доки.Дата
		|ИЗ
		|	Документ."+МетаданныеДокумента.Имя+" КАК Доки
		|ГДЕ
		|	Доки.Номер = &Номер
		|
		|УПОРЯДОЧИТЬ ПО
		|	Доки.Дата УБЫВ";
	Запрос = Новый Запрос(ТекстЗапроса);
	Если МетаданныеДокумента.ТипНомера = Метаданные.СвойстваОбъектов.ТипНомераДокумента.Число Тогда
		Номер = Число(Значение_Строкой);
	Иначе
		Номер = Значение_Строкой;
	КонецЕсли; 
	Запрос.УстановитьПараметр("Номер", Номер);
	
	Результат = Запрос.Выполнить();
	
	Значение = Неопределено;
	
	ВыборкаДетальныеЗаписи = Результат.Выбрать();
	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Значение = ВыборкаДетальныеЗаписи.Ссылка;
	Иначе
		ВызватьИсключение "Не удалось найти документ по номеру <"+Значение_Строкой+">. Тип Документ."+МетаданныеДокумента.Имя;	
	КонецЕсли;

	Возврат Значение;
КонецФункции

Функция НаборРеквизитовМетаданных(КорневойТип, МетаданныеОбъекта)
	НаборМдРеквизитов = Новый Структура;
	Если КорневойТип = "Справочник" 
			или КорневойТип = "Документ" 
			или КорневойТип = "ПланВидовХарактеристик"
			или КорневойТип = "БизнесПроцесс"
			или КорневойТип = "ПланОбмена" Тогда
			
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.СтандартныеРеквизиты, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Реквизиты, НаборМдРеквизитов);
	ИначеЕсли КорневойТип = "Задача" Тогда
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.СтандартныеРеквизиты, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Реквизиты, НаборМдРеквизитов);
		ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.РеквизитыАдресации, НаборМдРеквизитов);
		
	ИначеЕсли КорневойТип = "РегистрСведений" 
		или КорневойТип = "РегистрНакопления"
		или КорневойТип = "РегистрБухгалтерии" Тогда
		
			ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.СтандартныеРеквизиты, НаборМдРеквизитов);
			ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Измерения, НаборМдРеквизитов, КорневойТип);
			ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Ресурсы, НаборМдРеквизитов);
			ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МетаданныеОбъекта.Реквизиты, НаборМдРеквизитов);

	Иначе
		ВызватьИсключение "Необрабатываемый корневой тип <"+КорневойТип+">";
	КонецЕсли;
	Возврат НаборМдРеквизитов;
КонецФункции

Процедура ДобавитьРеквизитыМетаданныхВНаборРеквизитов(МдРеквизиты, НаборМдРеквизитов, КорневойТип = "")
	Для каждого МдРеквизит Из МдРеквизиты Цикл
		Если КорневойТип = "РегистрБухгалтерии" И Не МдРеквизит.Балансовый Тогда
			НаборМдРеквизитов.Вставить(МдРеквизит.Имя + "Дт", МдРеквизит);
			НаборМдРеквизитов.Вставить(МдРеквизит.Имя + "Кт", МдРеквизит);
		Иначе
			НаборМдРеквизитов.Вставить(МдРеквизит.Имя, МдРеквизит);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// }

//{ Методы проверки таблиц метаданных
Функция ПолучитьКоличествоДокументовПоОтбору(видДокумента, Дата1, дата2, структураОтбора = Неопределено) Экспорт
		ПроверитьЗаполненность(видДокумента, "видДокумента");
		ПроверитьЗаполненность(Дата1, "Дата1");
		ПроверитьЗаполненность(Дата2, "Дата2");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(Доки.Ссылка) КАК КоличествоДокументов
	|ИЗ
	|	Документ."+видДокумента+" КАК Доки
	|ГДЕ
	|	Доки.Дата МЕЖДУ &Дата1 И &Дата2
	|";
	Запрос.УстановитьПараметр("Дата1", Дата1);
	Запрос.УстановитьПараметр("Дата2", КонецДня(Дата2));
	
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоДокументов;
КонецФункции

Функция ПолучитьКоличествоЭлементовСправочникаПоОтбору(видСправочника, структураОтбора = Неопределено) Экспорт   			
	Возврат ПолучитьКоличествоЭлементовМетаданногоПоОтбору("Справочник", видСправочника, структураОтбора);     		
КонецФункции

Функция ПолучитьКоличествоСтрокВДокументахПоОтбору(видДокумента, имяТабличнойЧасти, Дата1, дата2, структураОтбораШапки = Неопределено, структураОтбораТабличнойЧасти = Неопределено) Экспорт
		ПроверитьЗаполненность(видДокумента, "видДокумента");
		ПроверитьЗаполненность(Дата1, "Дата1");
		ПроверитьЗаполненность(Дата2, "Дата2");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(Доки.Ссылка) КАК КоличествоДокументов
	|ИЗ
	|	Документ."+видДокумента+"."+имяТабличнойЧасти+" КАК Доки
	|ГДЕ
	|	Доки.Дата МЕЖДУ &Дата1 И &Дата2
	|";
	Запрос.УстановитьПараметр("Дата1", Дата1);
	Запрос.УстановитьПараметр("Дата2", КонецДня(Дата2));
	
	Если ЗначениеЗаполнено(структураОтбораШапки) Тогда
		Для каждого ключЗначение Из структураОтбораШапки Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки.Ссылка."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	Если ЗначениеЗаполнено(структураОтбораТабличнойЧасти) Тогда
		Для каждого ключЗначение Из структураОтбораТабличнойЧасти Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоДокументов;
КонецФункции

Функция ПолучитьИтоговуюСуммуТабличнойЧастиДокументовПоОтбору(видДокумента, имяТабличнойЧасти, имяРеквизита, Дата1, дата2, структураОтбораШапки = Неопределено, структураОтбораТабличнойЧасти = Неопределено) Экспорт
		ПроверитьЗаполненность(видДокумента, "видДокумента");
		ПроверитьЗаполненность(Дата1, "Дата1");
		ПроверитьЗаполненность(Дата2, "Дата2");
	Запрос = Новый Запрос;
	текстТабличнаяЧасть = ?(НЕ ЗначениеЗаполнено(имяТабличнойЧасти), "", "."+имяТабличнойЧасти);
	Запрос.Текст = "ВЫБРАТЬ
	|	СУММА(Доки."+имяРеквизита+") КАК Сумма
	|ИЗ
	|	Документ."+видДокумента+текстТабличнаяЧасть+" КАК Доки
	|ГДЕ
	|	Доки.Дата МЕЖДУ &Дата1 И &Дата2
	|";
	Запрос.УстановитьПараметр("Дата1", Дата1);
	Запрос.УстановитьПараметр("Дата2", КонецДня(Дата2));
	
	Если ЗначениеЗаполнено(структураОтбораШапки) Тогда
		Для каждого ключЗначение Из структураОтбораШапки Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки.Ссылка."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
		ПроверитьИстину(НЕ (имяТабличнойЧасти = "" И ЗначениеЗаполнено(структураОтбораТабличнойЧасти)), "табличная часть не должна быть указана");
	Если ЗначениеЗаполнено(структураОтбораТабличнойЧасти) Тогда
		Для каждого ключЗначение Из структураОтбораТабличнойЧасти Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Доки."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.Сумма;
КонецФункции

Функция ПолучитьИтоговуюСуммуДокументовПоОтбору(видДокумента, имяРеквизита, Дата1, дата2, структураОтбораШапки = Неопределено, структураОтбораТабличнойЧасти = Неопределено) Экспорт
	Возврат ПолучитьИтоговуюСуммуТабличнойЧастиДокументовПоОтбору(видДокумента, "", имяРеквизита, Дата1, дата2, структураОтбораШапки, структураОтбораТабличнойЧасти);
КонецФункции

Функция ПолучитьКоличествоЭлементовМетаданногоПоОтбору(типМетаданного, видМетаданного, структураОтбора = Неопределено) Экспорт
		ПроверитьЗаполненность(типМетаданного, "типМетаданного");
		ПроверитьЗаполненность(видМетаданного, "видМетаданного");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(Таб.Ссылка) КАК КоличествоЭлементов
	|ИЗ
	|	"+типМетаданного+"."+видМетаданного+" КАК Таб
	|ГДЕ
	|	Истина
	|";
	
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Таб."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоЭлементов;
КонецФункции

Функция ПолучитьКоличествоБизнесПроцессовПоОтбору(видМетаданного, структураОтбора = Неопределено) Экспорт
	Возврат ПолучитьКоличествоЭлементовМетаданногоПоОтбору("БизнесПроцесс", видМетаданного, структураОтбора);
КонецФункции

Функция ПолучитьКоличествоЗадачПоОтбору(видМетаданного, структураОтбора = Неопределено) Экспорт
	Возврат ПолучитьКоличествоЭлементовМетаданногоПоОтбору("Задача", видМетаданного, структураОтбора);
КонецФункции

Функция ПолучитьКоличествоЭлементовРегистраПоОтбору(типМетаданного, видМетаданного, структураОтбора = Неопределено) Экспорт
		ПроверитьЗаполненность(типМетаданного, "типМетаданного");
		ПроверитьЗаполненность(видМетаданного, "видМетаданного");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК КоличествоЭлементов
	|ИЗ
	|	"+типМетаданного+"."+видМетаданного+" КАК Таб
	|ГДЕ
	|	Истина
	|";
	
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Таб."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли; 
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат выборка.КоличествоЭлементов;
КонецФункции

Функция ПолучитьЭлементыМетаданногоПоОтбору(типМетаданного, видМетаданного, Количество=1, структураОтбора = Неопределено) Экспорт
	ПроверитьЗаполненность(типМетаданного, "типМетаданного");
	ПроверитьЗаполненность(видМетаданного, "видМетаданного");
		
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ "+Количество+"
	|	*
	|ИЗ
	|	"+типМетаданного+"."+видМетаданного+" КАК Таб
	|ГДЕ
	|	Истина
	|";
		
	Если ЗначениеЗаполнено(структураОтбора) Тогда
		Для каждого ключЗначение Из структураОтбора Цикл
			имяРеквизита = ключЗначение.Ключ;
			Запрос.Текст = Запрос.Текст + " И Таб."+имяРеквизита+" = &"+имяРеквизита+" ";
			Запрос.УстановитьПараметр(имяРеквизита, ключЗначение.Значение);
		КонецЦикла;
	КонецЕсли; 
	
	РезультатЗапроса = Запрос.Выполнить();
	ТЗ = РезультатЗапроса.Выгрузить();
	
	Возврат ТЗ;
КонецФункции

//}

//{ МЕТОДЫ ДЛЯ ВЫПОЛНЕНИЯ ТЕСТОВ

Функция ВыполнитьТесты(ЗапускаемыеТесты, ВызыватьИсключение = Ложь) Экспорт
	
	ПередВыполнениемТестов(ЗапускаемыеТесты);
	
	СостояниеРезультат = мЗначенияСостоянияТестов.НеВыполнялся;
	
	Для Каждого СтрокаДереваТестов Из ЗапускаемыеТесты Цикл
		#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		мВсегоТестов = мВсегоТестов + 1;
		НовоеСостояние = ВыполнитьТест(СтрокаДереваТестов, мСписокОшибок, РегистрацияПрохожденияТестовВЖР, РегистрацияОшибокТестовВЖР, ВызыватьИсключение);
		СтрокаДереваТестов.Состояние = НовоеСостояние;
		
		ЗапомнитьСамоеХудшееСостояние(СостояниеРезультат, НовоеСостояние);
		
	КонецЦикла;
	
	Возврат СостояниеРезультат;
	
КонецФункции

// Выполняет отдельный тест.
// 
Функция ВыполнитьТест(СтрокаДереваТестов, СписокОшибок, РегистрироватьПрохождениеТестаВЖР, РегистрироватьОшибкиТестаВЖР, ВызыватьИсключение = Ложь) Экспорт
	Перем Тест; // специально локальная переменная для исключения циклических ссылок
	
	ПредставлениеТестовогоСлучая = СтрокаДереваТестов.Имя;
	
	ТекущаяДатаВМиллисекундах = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ПолныйПуть = СтрокаДереваТестов.ПолныйПуть;
	
	Если РегистрироватьПрохождениеТестаВЖР Тогда
		ЗарегистрироватьНачалоПрохожденияТеста(ПредставлениеТестовогоСлучая, ПолныйПуть);
	КонецЕсли;
	
	СтрокаДереваТестов.СписокОшибок.Очистить();
	
	Попытка
		Тест = ПолучитьТестОбъект(СтрокаДереваТестов);
	Исключение
		Возврат ВывестиОшибкуВыполненияТеста(СтрокаДереваТестов, ИнформацияОбОшибке(), СписокОшибок, РегистрироватьОшибкиТестаВЖР);
	КонецПопытки;
	
	Если ЭтоПервыйТестовыйМетодНабора(СтрокаДереваТестов) Тогда
		Попытка
			ВыполнитьНеобязательнуюПроцедуруТестовогоСлучая(Тест, "ПередЗапускомНабораТестов");
		Исключение
			Возврат ВывестиОшибкуВыполненияТеста(СтрокаДереваТестов, ИнформацияОбОшибке(), СписокОшибок, РегистрироватьОшибкиТестаВЖР);
		КонецПопытки;
	КонецЕсли;
	
	УчестьЗапускТеста(СтрокаДереваТестов);
	
	СостояниеВыполнения = ВыполнитьМетодыТеста(Тест, СтрокаДереваТестов, СписокОшибок, РегистрироватьОшибкиТестаВЖР, ВызыватьИсключение);
	
	Если ЭтоПоследнийТестовыйМетодНабора(СтрокаДереваТестов) Тогда
		Попытка
			ВыполнитьНеобязательнуюПроцедуруТестовогоСлучая(Тест, "ПослеЗапускаНабораТестов");
		Исключение
			НовоеСостояние = ВывестиОшибкуВыполненияТеста(СтрокаДереваТестов, ИнформацияОбОшибке(), СписокОшибок, РегистрироватьОшибкиТестаВЖР);
			ЗапомнитьСамоеХудшееСостояние(СостояниеВыполнения, НовоеСостояние);
		КонецПопытки;
	КонецЕсли;
	
	СтрокаДереваТестов.ВремяВыполнения = Число(ТекущаяУниверсальнаяДатаВМиллисекундах() - ТекущаяДатаВМиллисекундах) / 1000;
	
	Возврат СостояниеВыполнения;
	
КонецФункции

Функция ВыполнитьМетодыТеста(Тест, СтрокаДереваТестов, СписокОшибок, РегистрироватьОшибкиТестаВЖР, ВызыватьИсключение)
	
	СостояниеВыполнения = мЗначенияСостоянияТестов.НеВыполнялся;
	
	ДанныеТекущегоТеста = ПустыеДанныеТекущегоТеста();
	ДанныеТекущегоТеста.Вставить("Имя", СтрокаДереваТестов.Имя);
	ДанныеТекущегоТеста.Вставить("ПолныйПуть", СтрокаДереваТестов.ПолныйПуть);
	ДанныеТекущегоТеста.Вставить("СостояниеТеста", СостояниеВыполнения);
	УстановитьДанныеТекущегоТеста(ДанныеТекущегоТеста);
	
	параметрыТеста = СтрокаДереваТестов.ПараметрыТеста;
	естьПараметры = СтрокаДереваТестов.ЕстьПараметрыТеста;
	
	естьТранзакция = Ложь;
	Если естьПараметры Тогда
		естьТранзакция = параметрыТеста.Свойство("Транзакция", естьТранзакция) И ТипЗнч(естьТранзакция) = Тип("Булево") И естьТранзакция;
		Если естьТранзакция Тогда
			НачатьТранзакцию();
		КонецЕсли;
	КонецЕсли;
		
	ЕстьТранзакцияДоНачалаОбработчика = ТранзакцияАктивна();
	
		//TODO Если первый раз запуск setup оказался неуспешным, то при повторном прогоне без перезагрузки
		// не выполнять, также не выполнять для следующих тестовых случаев.
	Попытка
		ВыполнитьНеобязательнуюПроцедуруТестовогоСлучая(Тест, "ПередЗапускомТеста");
	Исключение
		Если (естьТранзакция ИЛИ НЕ ЕстьТранзакцияДоНачалаОбработчика) и ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		
		Возврат ВывестиОшибкуВыполненияТеста(СтрокаДереваТестов, ИнформацияОбОшибке(), СписокОшибок, РегистрироватьОшибкиТестаВЖР);
	КонецПопытки;
	
	ОповеститьОСобытии("TestStart", СтрокаДереваТестов);
	
	ЕстьТранзакцияДоНачалаОбработчика = ТранзакцияАктивна();
	
	Попытка
		
		ВыполнитьТестовыйМетод(Тест, СтрокаДереваТестов, ВызыватьИсключение);
		СостояниеВыполнения = мЗначенияСостоянияТестов.Прошел;
		ОповеститьОСобытии("TestPassed", СтрокаДереваТестов);
		
	Исключение
		Если ВызыватьИсключение = Истина Тогда
			ВызватьИсключение;
		КонецЕсли;
		
		Если Не ЕстьТранзакцияДоНачалаОбработчика и ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		
		СостояниеВыполнения = ВывестиОшибкуВыполненияТеста(СтрокаДереваТестов, ИнформацияОбОшибке(), СписокОшибок, РегистрироватьОшибкиТестаВЖР);
		
	КонецПопытки;
	
	ДанныеТекущегоТеста.Вставить("СостояниеТеста", СостояниеВыполнения);
	УстановитьДанныеТекущегоТеста(ДанныеТекущегоТеста);
	
	ЕстьТранзакцияДоНачалаОбработчика = ТранзакцияАктивна();
	
	Попытка
		ВыполнитьНеобязательнуюПроцедуруТестовогоСлучая(Тест, "ПослеЗапускаТеста");
	Исключение
		Если Не ЕстьТранзакцияДоНачалаОбработчика и ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		
		НовоеСостояние = ВывестиОшибкуВыполненияТеста(СтрокаДереваТестов, ИнформацияОбОшибке(), СписокОшибок, РегистрироватьОшибкиТестаВЖР);
		ЗапомнитьСамоеХудшееСостояние(СостояниеВыполнения, НовоеСостояние);
	КонецПопытки;
	
	Если естьТранзакция Тогда
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
	КонецЕсли;
	
	УдалитьДанныеТекущегоТеста();
	
	Возврат СостояниеВыполнения;
	
КонецФункции

Процедура ВыполнитьТестовыйМетод(Тест, СтрокаДереваТестов, ВызыватьИсключение);
	
	ПредставлениеТестовогоСлучая = СтрокаДереваТестов.Имя;
	ИмяТестовогоСлучая = СтрокаДереваТестов.ИмяТестовогоСлучая;
	
	СтрокаПараметров = "";
	Если СтрокаДереваТестов.ЕстьПараметрыТеста Тогда
		ПараметрТеста = Неопределено;
		Если СтрокаДереваТестов.ПараметрыТеста.Свойство("Параметр", ПараметрТеста) Тогда
			СтрокаПараметров = "ПараметрТеста";
		КонецЕсли;
	КонецЕсли;
	
	Если ВызыватьИсключение = Истина Тогда
		ВызватьИсключение "ПередЗапускомТеста " + ПредставлениеТестовогоСлучая + " обработка:" + СтрокаДереваТестов.ПолныйПуть;
	КонецЕсли;
	
	Попытка
		ИcполняемыйКод = "Тест." + ИмяТестовогоСлучая + "(" + СтрокаПараметров + ");";
		Выполнить(ИcполняемыйКод);
	Исключение
		
		текстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, ИмяТестовогоСлучая) Тогда
			Сообщение = НСтр("ru = 'Отсутствует реализация тестового метода (%1).'");
			ПропуститьТест(СтрЗаменить(Сообщение, "%1", ИcполняемыйКод));
		Иначе
			ВызватьИсключение;
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

Функция ПолучитьТестОбъект(СтрокаДереваТестов)
	Перем Тест;
	
	ПолныйПуть = СтрокаДереваТестов.ПолныйПуть;
	
	Тест = кэшТестовыхОбработок.Получить(ПолныйПуть);
	Если Тест = Неопределено Тогда
		ИмяТестовойОбработки = СтрокаДереваТестов.ТестовыйСлучайОбъектМетаданныхИмя;
		Если СтрокаДереваТестов.ЭтоВнутренняяОбработка Тогда
			Тест = СоздатьОбъектОбработкиКонфигурации(ИмяТестовойОбработки);
		Иначе
			Тест = СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(ИмяТестовойОбработки);
		КонецЕсли;
		
		ТестИнициализирован = ВыполнитьНеобязательнуюПроцедуруТестовогоСлучая(Тест, "Инициализация", ЭтотОбъект);
		Если Не ТестИнициализирован Тогда
			
			массивТестов = ПолучитьТестовыеСлучаи(Тест, ПолныйПуть); // возможно, что тест сохранит у себя ссылку на браузер
			Если Не ЗначениеЗаполнено(массивТестов) Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось получить тестовые случаи'");
			КонецЕсли;
			
		КонецЕсли;
		
		кэшТестовыхОбработок.Вставить(ПолныйПуть, Тест);
		
	КонецЕсли;
	
	Возврат Тест;
	
КонецФункции

Функция ВыполнитьНеобязательнуюПроцедуруТестовогоСлучая(Тест, ИмяПроцедуры, Параметры = Неопределено)
	
	ПараметрыМетода = ПараметрыСтрокой(Параметры);
	
	Попытка
		Выполнить("Тест." + ИмяПроцедуры + "(" + ПараметрыМетода + ");");
	Исключение
		текстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) ;
		Если Не ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, ИмяПроцедуры) Тогда
			ВызватьИсключение;
		КонецЕсли;
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

Функция ВывестиОшибкуВыполненияТеста(СтрокаДереваТестов, ИнфоОшибки, СписокОшибок, РегистрироватьОшибкуВЖР)
	
	СостояниеВыполнения = мЗначенияСостоянияТестов.Сломался;
	
	СтруктураОшибки = Новый Структура();
	
	ТекстОшибки = КраткоеПредставлениеОшибки(ИнфоОшибки);
	Если ЭтоПропущенныйТест(ТекстОшибки) Тогда
		СостояниеВыполнения = мЗначенияСостоянияТестов.НеРеализован;
		СтруктураОшибки.Вставить("Статус", СтатусыРезультатаТестирования.ТестПропущен);
		стИнфоОшибки = Новый Структура;
		стИнфоОшибки.Вставить("Описание", ТекстОшибки);
	ИначеЕсли ЭтоОшибкаПроверки(ТекстОшибки) Тогда
		СтруктураОшибки.Вставить("Статус", СтатусыРезультатаТестирования.ОшибкаПроверки);
		стИнфоОшибки = Новый Структура;
		стИнфоОшибки.Вставить("Описание", ТекстОшибки);
	Иначе
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОшибки);
		СтруктураОшибки.Вставить("Статус", СтатусыРезультатаТестирования.НеизвестнаяОшибка);
		стИнфоОшибки = СкопироватьИнформациюОбОшибке(ИнфоОшибки);
	КонецЕсли;
	
	ПредставлениеТестовогоСлучая = СтрокаДереваТестов.Имя;
	СтруктураОшибки.Вставить("ИмяТестовогоНабора",    СтрокаДереваТестов.ИмяТестовогоНабора);
	СтруктураОшибки.Вставить("ИмяТестовогоСлучая",    ПредставлениеТестовогоСлучая);
	СтруктураОшибки.Вставить("Описание",              ТекстОшибки);
	СтруктураОшибки.Вставить("ИнфоОшибки",            стИнфоОшибки);
	СтруктураОшибки.Вставить("ЕстьПараметрыТеста",    СтрокаДереваТестов.ЕстьПараметрыТеста);
	СтруктураОшибки.Вставить("ПараметрыТеста",        СтрокаДереваТестов.ПараметрыТеста);
	СтруктураОшибки.Вставить("ПолныйПуть",            СтрокаДереваТестов.ПолныйПуть);
	СтруктураОшибки.Вставить("УИДСтрокиДерева",       СтрокаДереваТестов._guid);
	
	СтрокаДереваТестов.СписокОшибок.Добавить(СтруктураОшибки);
	СписокОшибок.Добавить(СтруктураОшибки);
	
	Если ЭтоСтрокаДереваУФ(СтрокаДереваТестов) Тогда
		СтруктураОшибки.Вставить("Идентификатор",       СтрокаДереваТестов.ПолучитьИдентификатор());
	Иначе
		СтруктураОшибки.Вставить("Идентификатор",       Неопределено);
	КонецЕсли;
	
	НужныйТекстОшибки = ВывестиОшибку(СтруктураОшибки);
	
	Если РегистрироватьОшибкуВЖР Тогда
		ЗарегистрироватьОшибкуТеста(НужныйТекстОшибки, ПредставлениеТестовогоСлучая, СтрокаДереваТестов.ПолныйПуть);
	КонецЕсли;
	
	Если СостояниеВыполнения = мЗначенияСостоянияТестов.НеРеализован Тогда
		ОповеститьОСобытии("TestNotImplemented", СтрокаДереваТестов);
	Иначе
		ОповеститьОСобытии("TestFailed", СтрокаДереваТестов);
	КонецЕсли;
	
	Возврат СостояниеВыполнения;
	
КонецФункции

Функция СкопироватьИнформациюОбОшибке(Знач ИнфоОшибки)
	
	стИнфоОшибки = Новый Структура("ИмяМодуля, ИсходнаяСтрока, НомерСтроки, Описание");
	ЗаполнитьЗначенияСвойств(стИнфоОшибки, ИнфоОшибки);
	стИнфоОшибки.Вставить("Причина", Неопределено);
	
	стИнфоОшибкиЦикл = стИнфоОшибки;
	ИнфоОшибки = ИнфоОшибки.Причина;
	Пока ИнфоОшибки <> Неопределено Цикл
		стИнфоОшибкиЦикл.Причина = Новый Структура("ИмяМодуля, ИсходнаяСтрока, НомерСтроки, Описание");
		стИнфоОшибкиЦикл = стИнфоОшибкиЦикл.Причина;
		ЗаполнитьЗначенияСвойств(стИнфоОшибкиЦикл, ИнфоОшибки);
		стИнфоОшибкиЦикл.Вставить("Причина", Неопределено);
		
		ИнфоОшибки = ИнфоОшибки.Причина;
	КонецЦикла;
	
	Возврат стИнфоОшибки;
	
КонецФункции

Функция ЭтоОшибкаПроверки(ТекстОшибки)
	
	Возврат Найти(ТекстОшибки, "["+ СтатусыРезультатаТестирования.ОшибкаПроверки + "]") = 1;
	
КонецФункции

Функция ЭтоПропущенныйТест(ТекстОшибки)
	
	Возврат Найти(ТекстОшибки, "["+ СтатусыРезультатаТестирования.ТестПропущен + "]") = 1;
	
КонецФункции

Процедура ПередВыполнениемТестов(ЗапускаемыеТесты)
	
	мСписокОшибок = Новый СписокЗначений;
	мВсегоТестов = 0;
	
	кэшТестовыхОбработок = Новый Соответствие;
	ИнициализироватьСостояниеВыполненияНаборовТестов(ЗапускаемыеТесты);
	
КонецПроцедуры

//{ КОНТРОЛЬ СОСТОЯНИЯ ВЫПОЛНЕНИЯ НАБОРОВ ТЕСТОВ

Процедура ИнициализироватьСостояниеВыполненияНаборовТестов(ЗапускаемыеТесты)
	
	СостояниеВыполненияНаборовТестов = Новый Структура;
	
	Для Каждого ТестовыйМетод Из ЗапускаемыеТесты Цикл
		
		ЗарегистрироватьТестовыйМетодКЗапуску(ТестовыйМетод);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗарегистрироватьТестовыйМетодКЗапуску(ТестовыйМетод)
	
	Состояние = СостояниеВыполненияНабораТестовТестовогоМетода(Тестовыйметод);
	Если Состояние = Неопределено Тогда
		Состояние = ДобавитьСостояниеВыполненияНабораТестовТестовогоМетода(ТестовыйМетод);
	КонецЕсли;
	
	Состояние.ТестыКЗапуску.Вставить(ИдентификаторПоУИД(ТестовыйМетод._GUID));
	
КонецПроцедуры

Функция ДобавитьСостояниеВыполненияНабораТестовТестовогоМетода(ТестовыйМетод)
	
	Состояние = Новый Структура;
	Состояние.Вставить("ЭтоПервыйТестВНаборе", Истина);
	Состояние.Вставить("ТестыКЗапуску", Новый Структура);
	
	СостояниеВыполненияНаборовТестов.Вставить(ИдентификаторТестовогоНабора(ТестовыйМетод), Состояние);
	Возврат Состояние;
	
КонецФункции

Процедура УчестьЗапускТеста(ТестовыйМетод)
	
	Состояние = СостояниеВыполненияНабораТестовТестовогоМетода(Тестовыйметод);
	Состояние.ТестыКЗапуску.Удалить(ИдентификаторПоУИД(ТестовыйМетод._GUID));
	Состояние.ЭтоПервыйТестВНаборе = Ложь;
	
КонецПроцедуры

Функция ЭтоПервыйТестовыйМетодНабора(ТестовыйМетод)
	
	Состояние = СостояниеВыполненияНабораТестовТестовогоМетода(ТестовыйМетод);
	Возврат Состояние.ЭтоПервыйТестВНаборе;
	
КонецФункции

Функция ЭтоПоследнийТестовыйМетодНабора(ТестовыйМетод)
	
	Состояние = СостояниеВыполненияНабораТестовТестовогоМетода(Тестовыйметод);
	Возврат (Состояние.ТестыКЗапуску.Количество() = 0);
	
КонецФункции

Функция СостояниеВыполненияНабораТестовТестовогоМетода(Тестовыйметод)
	Перем Состояние;
	
	СостояниеВыполненияНаборовТестов.Свойство(ИдентификаторТестовогоНабора(ТестовыйМетод), Состояние);
	Возврат Состояние;
	
КонецФункции

Функция ИдентификаторТестовогоНабора(ТестовыйМетод)
	
	ТестовыйНабор = РодительскаяСтрока(ТестовыйМетод);
	Возврат ИдентификаторПоУИД(ТестовыйНабор._GUID) + ТестовыйМетод.ИмяОсновнойУправляемойФормы;
	
КонецФункции

Функция ИдентификаторПоУИД(УИД)
	
	Возврат "_" + СтрЗаменить(УИД, "-", "_");
	
КонецФункции

//}

//{ МЕТОДЫ ЗАГРУЗКИ ТЕСТОВ

Функция ЗагрузитьТестыКонфигурации(ДеревоТестов, Путь) Экспорт
	Если ЗначениеЗаполнено(Путь) Тогда
		мКоличествоТестовыхСлучаев = 0;
		ОбъектМетаданных = ПолучитьОбъектМетаданныхПоПути(Путь);
		Если ОбъектМетаданных <> Неопределено Тогда
			Если ВРег(Лев(ОбъектМетаданных.ПолноеИмя(),11)) = "ПОДСИСТЕМА." Тогда
				ЗагрузитьТестыПодсистемы(ДеревоТестов, ОбъектМетаданных);
			Иначе
				ЗагрузитьВстроенныйТестовыйСлучай(ДеревоТестов, ОбъектМетаданных);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецФункции

// Загружает тесты в дерево тестов из подсистемы конфигурации.
//
Функция ЗагрузитьТестыПодсистемы(СтрокаДерева,Подсистема) Экспорт
	
	ПолныйПуть = СтрЗаменить("Метаданные." + Подсистема.ПолноеИмя(), ".Подсистема.", ".Подсистемы.");
	СтрокаТеста = ДобавитьСтрокуДереваТестов(СтрокаДерева, мЗначенияТиповСтроки.Подсистема, ПолныйПуть, Подсистема.Имя);
	
	Для каждого ПодчиненнаяПодсистема из Подсистема.Подсистемы цикл
		ЗагрузитьТестыПодсистемы(СтрокаТеста,ПодчиненнаяПодсистема);
	КонецЦикла;
	
	Для каждого Обработка из Подсистема.Состав цикл
		Если Метаданные.Обработки.Найти(Обработка.Имя) <> Неопределено Тогда
			ЗагрузитьВстроенныйТестовыйСлучай(СтрокаТеста,Обработка);
		КонецЕсли;
	КонецЦикла;
	
	Если ПодчиненныеСтроки(СтрокаТеста).Количество() = 0 Тогда
		ПодчиненныеСтроки(СтрокаДерева).Удалить(СтрокаТеста);
	КонецЕсли;
	
КонецФункции

// Загружает тестовый случай (обработку) 
//
Функция ЗагрузитьВстроенныйТестовыйСлучай(СтрокаДерева,Обработка)
	ДанныеОбработки = новый Структура("ПолноеИмя,ИмяБезРасширения");
	ДанныеОбработки.ПолноеИмя = СтрЗаменить("Метаданные." + Обработка.ПолноеИмя(), ".Обработка.", ".Обработки.");
	ДанныеОбработки.ИмяБезРасширения = Обработка.Имя;
	ДобавитьТест(СтрокаДерева, ДанныеОбработки, Истина);
КонецФункции

// Загружает тесты в дерево тестов из каталога.
// 
Функция ЗагрузитьВсеТесты(КоллекцияФайловКаталогов) Экспорт
	
	мКоличествоТестовыхСлучаев = 0;
	
	ДеревоТестов.Строки.Очистить();
	
	Для Каждого ПутьКТесту из КоллекцияФайловКаталогов Цикл
		Если Найти(ВРег(ПутьКТесту), "МЕТАДАННЫЕ.") = 1 Тогда
			ЗагрузитьТестыКонфигурации(ДеревоТестов, ПутьКТесту);
		Иначе
			ОбъектФайл = Новый Файл(ПутьКТесту);
			Если ОбъектФайл.Существует() Тогда
				ЗагрузитьТесты(ДеревоТестов, ОбъектФайл);
			Иначе
				ВывестиОшибку(НСтр("en = 'File or directory does not exist ""'; ru = 'Файл или каталог не существует ""'") +
			                           ОбъектФайл.ПолноеИмя + """");
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Выполняет рекурсивную загрузку тестов и тестовых случаев
// из обработки или каталога с обработками для тестирования.
// 
Функция ЗагрузитьТесты(РодительскаяСтрока, ОбъектФайл)
	
	Если ОбъектФайл.ЭтоКаталог() Тогда
		Если ОбъектФайл.ПолучитьНевидимость() и ОбъектФайл.Имя = ".git" Тогда
			Возврат Истина;
		КонецЕсли;
		
		СтрокаКаталога = ДобавитьСтрокуДереваТестов(РодительскаяСтрока, мЗначенияТиповСтроки.КаталогТестов, ОбъектФайл.ПолноеИмя, ОбъектФайл.Имя);
		
		НайденныеФайлы = НайтиФайлы(ОбъектФайл.ПолноеИмя, "*", Ложь);
		Для каждого Файл из НайденныеФайлы Цикл
			#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
			#КонецЕсли 
			
			Если Файл.ЭтоКаталог() Тогда
				
				ЗагрузитьТесты(СтрокаКаталога, Файл);
				 
			ИначеЕсли НРег(Файл.Расширение) = ".epf" Тогда
				
				ДобавитьТест(СтрокаКаталога, Файл);
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтрокаКаталога.Строки.Количество() = 0 Тогда
			РодительскаяСтрока.Строки.Удалить(СтрокаКаталога);
		КонецЕсли;
		
	Иначе
		
		Если РодительскаяСтрока = ДеревоТестов ИЛИ РодительскаяСтрока.ТипСтроки = мЗначенияТиповСтроки.КаталогТестов Тогда
			ДобавитьТест(РодительскаяСтрока, ОбъектФайл);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// Добавляет тестовую обработку (тест) в дерево тестов.
// 
Процедура ДобавитьТест(РодительскаяСтрока, ФайлТеста, ЭтоВнутренняяОбработка = Ложь) Экспорт
	
	Перем ТестОбъект; // специально локальная переменная для исключения циклических ссылок
	
	ПолныйПуть = ФайлТеста.ПолноеИмя;
	Попытка
		Если ЭтоВнутренняяОбработка Тогда
			ТестОбъект = СоздатьОбъектОбработкиКонфигурации(ФайлТеста.ИмяБезРасширения);
		Иначе
			ТестОбъект = СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(ПолныйПуть);
		КонецЕсли;
	Исключение
		ТекстОшибки = НСтр("ru = 'Тест не загружен: %1'");
		ВывестиОшибку(СтрЗаменить(ТекстОшибки, "%1", ПолныйПуть) + Символы.ПС + ОписаниеОшибки());
		Возврат;
	КонецПопытки;
	
	МассивТестовыхСлучаев = ПолучитьТестовыеСлучаи(ТестОбъект, ПолныйПуть);
	
	Если ЗначениеЗаполнено(МассивТестовыхСлучаев) Тогда
		РазрешенСлучайныйПорядокВыполнения = Истина;
		Попытка
			РазрешенСлучайныйПорядокВыполнения = РазрешенСлучайныйПорядокВыполненияТестов(ТестОбъект, ПолныйПуть);
		Исключение
			МассивТестовыхСлучаев = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(МассивТестовыхСлучаев) Тогда
		Представление = ФайлТеста.ИмяБезРасширения;
		СтрокаТеста = ДобавитьСтрокуДереваТестов(РодительскаяСтрока, мЗначенияТиповСтроки.ТестовыйСлучай, ПолныйПуть, Представление,
			ФайлТеста.ИмяБезРасширения, ЭтоВнутренняяОбработка, РазрешенСлучайныйПорядокВыполнения);
		
		Для каждого ТестовыйСлучай из МассивТестовыхСлучаев Цикл
			#Если Клиент Тогда
				ОбработкаПрерыванияПользователя();
			#КонецЕсли 
			
			Если ТипЗнч(ТестовыйСлучай) = Тип("Строка") Тогда
				имяТестовогоСлучая = ТестовыйСлучай;
				параметрыТеста = Неопределено;
				ПредставлениеТеста = имяТестовогоСлучая;
			Иначе
				имяТестовогоСлучая = ТестовыйСлучай.ИмяТеста;
				параметрыТеста = ТестовыйСлучай;
				Если НЕ ТестовыйСлучай.Свойство("ПредставлениеТеста", ПредставлениеТеста) или не ЗначениеЗаполнено(ПредставлениеТеста) Тогда
					ПредставлениеТеста = имяТестовогоСлучая;
				КонецЕсли;
			КонецЕсли;
			
			ТестовыйСлучайОбъектМетаданныхИмя = ?(ЭтоВнутренняяОбработка, ФайлТеста.ИмяБезРасширения, ПолныйПуть);
			ДобавитьСтрокуДереваТестов(СтрокаТеста, мЗначенияТиповСтроки.ТестовыйМетод, ПолныйПуть, ПредставлениеТеста,
										ТестовыйСлучайОбъектМетаданныхИмя, ЭтоВнутренняяОбработка, РазрешенСлучайныйПорядокВыполнения,
										имяТестовогоСлучая, параметрыТеста);
			
			мКоличествоТестовыхСлучаев = мКоличествоТестовыхСлучаев + 1;
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Добавляет в дерево тестов новую строку.
// 
Функция ДобавитьСтрокуДереваТестов(РодительскаяСтрока, ТипСтроки, ПолныйПуть, Представление,
									ТестовыйСлучайОбъектМетаданныхИмя = "", ЭтоВнутренняяОбработка = Ложь, РазрешенСлучайныйПорядокВыполнения = Истина,
									ИмяТестовогоСлучая = "", ПараметрыТеста = Неопределено)
	
	НоваяСтрока = ПодчиненныеСтроки(РодительскаяСтрока).Добавить();
	
	НоваяСтрока.ТипСтроки = ТипСтроки;
	НоваяСтрока.ПолныйПуть = ПолныйПуть;
	НоваяСтрока.Имя = Представление;
	НоваяСтрока.Состояние = мЗначенияСостоянияТестов.НеВыполнялся;
	НоваяСтрока._guid = Строка(Новый УникальныйИдентификатор());
	
	Если ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Или ТипСтроки = мЗначенияТиповСтроки.ТестовыйСлучай Тогда
		НоваяСтрока.ТестовыйСлучайОбъектМетаданныхИмя = ТестовыйСлучайОбъектМетаданныхИмя;
		НоваяСтрока.ЭтоВнутренняяОбработка = ЭтоВнутренняяОбработка;
		НоваяСтрока.РазрешенСлучайныйПорядокВыполнения = РазрешенСлучайныйПорядокВыполнения;
	КонецЕсли;
	
	Если ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
		НоваяСтрока.ИмяТестовогоНабора = РодительскаяСтрока.Имя;
		НоваяСтрока.ИмяТестовогоСлучая = ИмяТестовогоСлучая;
		НоваяСтрока.МодульИлиФорма = мЗначениеМодульИлиФорма.Модуль;
	
		НоваяСтрока.ЕстьПараметрыТеста = ПараметрыТеста <> Неопределено;
		Если НоваяСтрока.ЕстьПараметрыТеста Тогда
			НоваяСтрока.ПараметрыТеста = ПараметрыТеста;
			Если НоваяСтрока.Имя = НоваяСтрока.ИмяТестовогоСлучая Тогда
				описаниеПараметра = "<пусто>";
				Если ПараметрыТеста.Свойство("Параметр") Тогда
					описаниеПараметра = Строка(ПараметрыТеста.Параметр);
				КонецЕсли;
				
				НоваяСтрока.Имя = НоваяСтрока.Имя + " ( " + описаниеПараметра + " )";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ОповеститьОСобытии("TestLoaded", НоваяСтрока);
	
	Возврат НоваяСтрока;
	
КонецФункции

//}

// получает мИнформатор. Возвращает Неопределено, если мИнформатор не удалось загрузить
Функция ПолучитьИнформатор() Экспорт
	
#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
	ВызватьИсключение "Информатор пока можно использовать только в толстом клиенте обычного приложения!";
#КонецЕсли
	
	Если мИнформатор = Неопределено И мПытаемсяСоздатьИнформатор Тогда
		СистемнаяИнформация = Новый СистемнаяИнформация;
		используемПлатформу8_3 = Лев(СистемнаяИнформация.ВерсияПриложения, 3) = "8.3";
		Если используемПлатформу8_3 Тогда
			мПытаемсяСоздатьИнформатор = Ложь;
			Возврат Неопределено;
		КонецЕсли;
		
		
		Если ЭтоВстроеннаяОбработка Тогда
			Попытка
				мИнформатор = Неопределено;
				Выполнить("мИнформатор = Обработки.xddInformator.Создать();");
			Исключение
				ВывестиОшибку("Класс Информатор не удалось создать <Обработки.xddInformator>");
				
				мИнформатор = Неопределено;
				мПытаемсяСоздатьИнформатор = Ложь;
				Возврат Неопределено;
			КонецПопытки;
		Иначе
			НайденноеИмяФайла = Неопределено;
			Выполнить("НайденноеИмяФайла = ЭтотОбъект.ИспользуемоеИмяФайла;");
			файл = Новый Файл(НайденноеИмяФайла);
			
			путьИнформатора = файл.Путь + "xddInformator.epf";
			файл = Новый Файл(путьИнформатора);
			
			Если НЕ файл.Существует() Тогда
				ВывестиОшибку("Класс Информатор не найден <"+путьИнформатора+">");
				Возврат Неопределено;
			КонецЕсли;
			
			Попытка
				мИнформатор = СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(путьИнформатора);
			Исключение
				ВывестиОшибку("Класс Информатор не удалось создать <"+путьИнформатора+">");
				
				мИнформатор = Неопределено;
				мПытаемсяСоздатьИнформатор = Ложь;
				Возврат Неопределено;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Возврат мИнформатор;
КонецФункции

// Получает с помощью Информатора массив тестовых экспортных методов, начинающихся с Тест
// может вызываться из теста из его метода ПолучитьСписокТестов(ЮнитТестирование)
Функция ДобавитьПростыеТестыИзОбъекта(массивТестов, ТестовыйОбъект) Экспорт
	Если мИнформатор = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		ТаблицаМетодов = мИнформатор.ПолучитьТаблицуМетодов(ТестовыйОбъект);

		Для каждого СтрокаТаблицыМетодов из ТаблицаМетодов Цикл
			наименованиеТеста = СтрокаТаблицыМетодов.Наименование;
			Если НРег(Лев(наименованиеТеста, 4)) = "тест" 
				И СтрокаТаблицыМетодов.КоличествоПараметров = 0 Тогда
				
				Если массивТестов.Найти(наименованиеТеста) = Неопределено Тогда
					массивТестов.Добавить(наименованиеТеста);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Исключение
		ВывестиОшибку("Ошибка получения списка тестовых случаев: " + ОписаниеОшибки());		
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

// Возвращает массив тестовых случаев обработки для тестирования.
Функция ПолучитьТестовыеСлучаи(ТестОбъект, ПолноеИмяОбъекта)

	Попытка
        
		#Если ТолстыйКлиентОбычноеПриложение Тогда
					//#Если Клиент Тогда
			получаемСписокТестовИзТестОбъекта = мИнформатор = Неопределено 
				или мИнформатор.МетодСуществует(ТестОбъект, "ПолучитьСписокТестов"); // после вызова Информатора появляются циклические ссылки
			Если НЕ получаемСписокТестовИзТестОбъекта Тогда
				Возврат Неопределено;
			КонецЕсли;
		
        #Иначе
			получаемСписокТестовИзТестОбъекта = Истина;
        #КонецЕсли    
		
		Если получаемСписокТестовИзТестОбъекта Тогда
			МассивТестовыхСлучаев = ТестОбъект.ПолучитьСписокТестов(ЭтотОбъект);
		КонецЕсли;
		
	Исключение
		текстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) ;
		
		// TODO если не использовать переменную ниже, а поставить вызов метода в условие, то будет глюк - внутрь условия не попадаем !
		ЕстьОшибка_МетодОбъектаНеОбнаружен = ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, "ПолучитьСписокТестов");
		Если НЕ ЕстьОшибка_МетодОбъектаНеОбнаружен Тогда
		
			ВывестиОшибку("Набор тестов не загружен: " + ПолноеИмяОбъекта + "
			|	Ошибка получения списка тестовых случаев: " + ОписаниеОшибки());
			
			ТестОбъект = Неопределено;
		КонецЕсли;
		
		Возврат Неопределено;			
				
	КонецПопытки;

	Если ТипЗнч(МассивТестовыхСлучаев) <> Тип("Массив") Тогда
		
			//Если выводитьОшибку Тогда
		ВывестиОшибку("Набор тестов не загружен: " + ПолноеИмяОбъекта + "
		|	Ошибка получения списка тестовых случаев: вместо массива имен тестовых случаев получен объект <" + Строка(ТипЗнч(МассивТестовыхСлучаев)) + ">");
			//КонецЕсли;
		ТестОбъект = Неопределено;
		Возврат Неопределено;			
		
	КонецЕсли;
	
	Если НЕ ПроверитьМассивТестовыхСлучаев(МассивТестовыхСлучаев, ТестОбъект, ПолноеИмяОбъекта) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат МассивТестовыхСлучаев;
	
КонецФункции

Функция ПроверитьМассивТестовыхСлучаев(МассивТестовыхСлучаев, ТестОбъект, ПолноеИмяОбъекта)
	Для каждого данныеТеста из МассивТестовыхСлучаев Цикл
		Если ТипЗнч(данныеТеста) = Тип("Строка") Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(данныеТеста) <> Тип("Структура") Тогда
			ВывестиОшибку("Набор тестов не загружен: " + ПолноеИмяОбъекта + "
			|	Ошибка получения структуры описания тестового случая: " + ОписаниеОшибки());
			Возврат Ложь;
		КонецЕсли;
		Если НЕ данныеТеста.Свойство("ИмяТеста") Тогда
			ВывестиОшибку("Набор тестов не загружен: " + ПолноеИмяОбъекта + "
			|	Не задано имя теста в структуре описания тестового случая: " + ОписаниеОшибки());
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

Функция РазрешенСлучайныйПорядокВыполненияТестов(ТестОбъект, ПолноеИмяОбъекта) Экспорт
	Рез = Истина;
	ИмяМетода = "РазрешенСлучайныйПорядокВыполненияТестов";
	Попытка
        
		Рез = ТестОбъект.РазрешенСлучайныйПорядокВыполненияТестов();
		
	Исключение
		текстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) ;
		
		// TODO если не использовать переменную ниже, а поставить вызов метода в условие, то будет глюк - внутрь условия не попадаем !
		ЕстьОшибка_МетодОбъектаНеОбнаружен = ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, ИмяМетода);
		Если НЕ ЕстьОшибка_МетодОбъектаНеОбнаружен Тогда
		
			ТекстОшибки = НСтр("ru = 'Набор тестов не загружен: %1:
									 |  Ошибка вызова метода %2 из теста: %3'");
			ТекстОшибки = СтрЗаменить(ТекстОшибки, "%1", ПолноеИмяОбъекта);
			ТекстОшибки = СтрЗаменить(ТекстОшибки, "%2", ИмяМетода);
			ТекстОшибки = СтрЗаменить(ТекстОшибки, "%3", ОписаниеОшибки());
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		
	КонецПопытки;
		
	Возврат Рез;
		
КонецФункции

// Возвращает количество подчиненных тестовых случаев для заданной строки дерева тестов.
// 
Функция ПолучитьКоличествоТестовыхСлучаев(СтрокаДереваТестов) Экспорт
	
	Если СтрокаДереваТестов.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
		Возврат 1;		
	КонецЕсли;	
	
	КоличествоТестовыхСлучаев = 0;
	Для каждого ПодчиненнаяСтрока из СтрокаДереваТестов.Строки Цикл
		КоличествоТестовыхСлучаев = КоличествоТестовыхСлучаев + ПолучитьКоличествоТестовыхСлучаев(ПодчиненнаяСтрока);
	КонецЦикла;
	
	Возврат КоличествоТестовыхСлучаев;
	
КонецФункции

//{ ФОРМИРОВАНИЕ ОТЧЕТА О ТЕСТИРОВАНИИ

Функция ПолучитьОтчетТестирования(ДеревоТестов, датаНачалаТестирования, ТипОтчета = "mxl", СписокОшибок, ВсегоТестов) Экспорт
	
	Если ТипОтчета = "xml" Тогда
		Отчет = ВывестиОтчетТестированияВФорматеJunitXML(ДеревоТестов, датаНачалаТестирования, ВсегоТестов, СписокОшибок);
	Иначе
		Отчет = ВывестиОтчетТестированияВоВнутреннемФормате(ДеревоТестов, датаНачалаТестирования, СписокОшибок, ВсегоТестов)
	КонецЕсли;
	
	Возврат Отчет;
	
КонецФункции

//{ Отчет в формате JUnit

Процедура ЗаполнитьРезультатТестовогоСлучая(ЗаписьXML, СтрокаТестов)
	
	#Если _ Тогда
	ЗаписьXML = Новый ЗаписьXML;
	#КонецЕсли
	ИмяТестовогоНабора = СтрокаТестов.ТестовыйНаборИмя;
	
	Если СтрокаТестов.Строки.Количество() > 0 Тогда
		Для Каждого Ошибка Из СтрокаТестов.Строки Цикл
			Если Ошибка.Статус = СтатусыРезультатаТестирования.ОшибкаПроверки Тогда
				Статус = "failure";
			ИначеЕсли Ошибка.Статус = СтатусыРезультатаТестирования.ТестПропущен Тогда
				Статус = "skipped";
			Иначе
				Статус = "error";
			КонецЕсли;
			
			ЗаписьXML.ЗаписатьНачалоЭлемента("testcase");
			ЗаписьXML.ЗаписатьАтрибут("classname", ИмяТестовогоНабора);
			ЗаписьXML.ЗаписатьАтрибут("name", СтрокаТестов.ТестовыйМетодИмя);
			ЗаписьXML.ЗаписатьАтрибут("time", XMLСтрока(СтрокаТестов.ВремяВыполнения));
			ЗаписьXML.ЗаписатьАтрибут("status", Статус);
			
			ЗаписьXML.ЗаписатьНачалоЭлемента(Статус);
			
			СтрокаОписание = Ошибка.Описание;
			Поз = НайтиНедопустимыеСимволыXML(СтрокаОписание);
			Если Поз <> 0 Тогда
				Поз = 1;
				КоличествоПовторов = СтрДлина(СтрокаОписание);
				
				Пока КоличествоПовторов > 0 Цикл
					Поз = НайтиНедопустимыеСимволыXML(СтрокаОписание, Поз);
					Если Поз = 0 Тогда
						Прервать;
					КонецЕсли; 
					КоличествоПовторов = КоличествоПовторов - 1;
					СтрокаОписание = Лев(СтрокаОписание, Поз-1) + Сред(СтрокаОписание, Поз+1);
				КонецЦикла; 
			КонецЕсли; 
			XMLОписание = XMLСтрока(СтрокаОписание);
			ЗаписьXML.ЗаписатьАтрибут("message", XMLОписание);
			
			ЗаписьXML.ЗаписатьКонецЭлемента();
			
			ЗаписьXML.ЗаписатьКонецЭлемента();
		КонецЦикла;
	Иначе
		ЗаписьXML.ЗаписатьНачалоЭлемента("testcase");
		ЗаписьXML.ЗаписатьАтрибут("classname", ИмяТестовогоНабора);
		ЗаписьXML.ЗаписатьАтрибут("name", СтрокаТестов.ТестовыйМетодИмя);
		ЗаписьXML.ЗаписатьАтрибут("time", XMLСтрока(СтрокаТестов.ВремяВыполнения));
		ЗаписьXML.ЗаписатьАтрибут("status", "passed");
		ЗаписьXML.ЗаписатьКонецЭлемента();
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьРезультатТестовИерархически(ЗаписьXML, СтрокаТестов)
	
	#Если _ Тогда
	ЗаписьXML = Новый ЗаписьXML;
	#КонецЕсли
	
	Если СтрокаТестов.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
		
		ЗаполнитьРезультатТестовогоСлучая(ЗаписьXML, СтрокаТестов);
		Возврат;
		
	КонецЕсли;
		
	ЗаписьXML.ЗаписатьНачалоЭлемента("testsuite");
	ЗаписьXML.ЗаписатьАтрибут("name", СтрокаТестов.ТестовыйНаборИмя);
	ЗаписьXML.ЗаписатьНачалоЭлемента("properties");
	
	//Если СтрокаТестов.ЕстьПараметрыТеста Тогда
	//	ЗаписьXML.ЗаписатьНачалоЭлемента("property");
	//	ЗаписьXML.ЗаписатьАтрибут("ЕстьПараметрыТеста",XMLСтрока(СтрокаТестов.ЕстьПараметрыТеста));
	//	ЗаписьXML.ЗаписатьКонецЭлемента();
	//КонецЕсли;
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
	Для Каждого ЭлементСтроки из СтрокаТестов.Строки Цикл 
		
		Если ЭлементСтроки.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда 
			ЗаполнитьРезультатТестовогоСлучая(ЗаписьXML, ЭлементСтроки);
		Иначе
			ЗаполнитьРезультатТестовИерархически(ЗаписьXML, ЭлементСтроки)
		КонецЕсли;
		
	КонецЦикла;
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
КонецПроцедуры

Функция ВывестиОтчетТестированияВФорматеJunitXML(АдресОсновныхДанных, датаНачалаТестирования, ВсегоТестов, СписокОшибок) Экспорт 
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку("UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	
	ДанныеОтчета = ПолучитьДанныеОтчетаТестирования(АдресОсновныхДанных, СписокОшибок);
	
	Если ДанныеОтчета.Строки.Количество() = 0 Тогда
		ИтогиТестирования = Неопределено;
		КоличествоОшибокПроверок = 0;
		КоличествоПропущенныхТестов = 0;
		КоличествоПрочихОшибок = 0;
	Иначе
		ИтогиТестирования = ДанныеОтчета.Строки[0];
		КоличествоОшибокПроверок = ИтогиТестирования.ОшибкаПроверки;
		КоличествоПропущенныхТестов = ИтогиТестирования.Пропущен;
		КоличествоПрочихОшибок = ИтогиТестирования.НеизвестнаяОшибка;
	КонецЕсли;
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("testsuites");
	ЗаписьXML.ЗаписатьАтрибут("tests", XMLСтрока(ВсегоТестов));
	ЗаписьXML.ЗаписатьАтрибут("name", XMLСтрока("1CUNIT")); //TODO: указывать путь к набору тестов. 
	ЗаписьXML.ЗаписатьАтрибут("time", XMLСтрока(ТекущаяДата() - датаНачалаТестирования));
	ЗаписьXML.ЗаписатьАтрибут("failures", XMLСтрока(КоличествоОшибокПроверок));
	ЗаписьXML.ЗаписатьАтрибут("errors", XMLСтрока(КоличествоПрочихОшибок));
	ЗаписьXML.ЗаписатьАтрибут("skipped", XMLСтрока(КоличествоПропущенныхТестов));
	
	Если ИтогиТестирования <> Неопределено Тогда
		Для Каждого ЭлементСтроки из ИтогиТестирования.Строки Цикл
			ЗаполнитьРезультатТестовИерархически(ЗаписьXML, ЭлементСтроки);
		КонецЦикла;
	КонецЕсли;
	
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

//}

//{ Отчет во внутреннем формате (ТабличныйДокумент)

Функция ВывестиОтчетТестированияВоВнутреннемФормате(АдресОсновныхДанных, датаНачалаТестирования, СписокОшибок, ВсегоТестов)
	
	КоличествоОшибок = СписокОшибок.Количество();
	Если КоличествоОшибок = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПрошлоВремени = ТекущаяДата() - датаНачалаТестирования;
	
	Отчет = Новый ТабличныйДокумент;
	Макет = ПолучитьМакет("ОтчетТестирования");
	
	ТолькоОшибки = Истина;
	ДанныеОтчета = ПолучитьДанныеОтчетаТестирования(АдресОсновныхДанных, СписокОшибок, ТолькоОшибки);
	
	ИтогиТестирования = ДанныеОтчета.Строки[0];
	
	КоличествоОшибокПроверок = ИтогиТестирования.ОшибкаПроверки;
	КоличествоПропущенныхТестов = ИтогиТестирования.Пропущен;
	КоличествоПрочихОшибок = ИтогиТестирования.НеизвестнаяОшибка;
	
	Секция = Макет.ПолучитьОбласть("Заголовок");
	Секция.Параметры.ВсегоТестов = ВсегоТестов;
	Секция.Параметры.НеПрошлоПроверку = КоличествоОшибокПроверок;
	Секция.Параметры.ПрочиеОшибки = КоличествоПрочихОшибок;
	Секция.Параметры.Пропущено = КоличествоПропущенныхТестов;
	Секция.Параметры.ПрошлоВремени = ПрошлоВремени;
	Секция.Параметры.ПрошлоВремениСтрока = формат(Дата(1,1,1) + ПрошлоВремени, "ДЛФ=T");
	Секция.Параметры.ВремяВыполненияОдногоТеста = ?(ВсегоТестов = 0, "", Формат(ПрошлоВремени / ВсегоТестов * 1000, "ЧЦ=15; ЧДЦ=2"));
	Отчет.Вывести(Секция);
	
	Отчет.НачатьАвтогруппировкуСтрок();
	ВывестиДанныеОтчетаТестированияРекурсивно(ИтогиТестирования.Строки, Макет, Отчет);
	Отчет.ЗакончитьАвтогруппировкуСтрок();
	
	Отчет.ОтображатьСетку = Ложь;
	Отчет.Защита = Ложь;
	Отчет.ТолькоПросмотр = Ложь;
	Отчет.ОтображатьЗаголовки = Ложь;
	
	Возврат Отчет;
	
КонецФункции

Процедура ВывестиДанныеОтчетаТестированияРекурсивно(ДанныеОтчета, Макет, Отчет, Уровень = 0)
	
	Для Каждого Данные Из ДанныеОтчета Цикл
		
		Если Данные.ТипСтроки = мЗначенияТиповСтроки.Ошибка Тогда
			
			Секция = Макет.ПолучитьОбласть("R1C1:R2C3");
			Секция.Область("R1C3").Текст = Данные.Описание;
			Отчет.Вывести(Секция, Уровень + 3);
			
		Иначе
			
			Если Данные.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
			
				Секция = Макет.ПолучитьОбласть("НаименованиеТеста");
				ЗаполнитьЗначенияСвойств(Секция.Параметры, Данные);
				Отчет.Вывести(Секция, Уровень + 2);
				
				Если Данные.ТестовыйМетодЕстьПараметрыТеста Тогда
					Секция = Макет.ПолучитьОбласть("ПараметрыТеста");
					ЗаполнитьЗначенияСвойств(Секция.Параметры, Данные);
					Отчет.Вывести(Секция, Уровень + 2);
				КонецЕсли;
				
			Иначе
				
				Секция = Макет.ПолучитьОбласть("НаименованиеНабора");
				ЗаполнитьЗначенияСвойств(Секция.Параметры, Данные);
				Если Данные.ТипСтроки = мЗначенияТиповСтроки.ТестовыйСлучай Тогда
					Секция.Параметры.Набор = НСтр("ru = 'Набор'");
				ИначеЕсли Данные.ТипСтроки = мЗначенияТиповСтроки.КаталогТестов Тогда
					Секция.Параметры.Набор = НСтр("ru = 'Каталог'");
				ИначеЕсли Данные.ТипСтроки = мЗначенияТиповСтроки.Подсистема Тогда
					Секция.Параметры.Набор = НСтр("ru = 'Подсистема'");
				КонецЕсли;
				
				Отчет.Вывести(Секция, Уровень + 1);
				
			КонецЕсли;
			
			ВывестиДанныеОтчетаТестированияРекурсивно(Данные.Строки, Макет, Отчет, Уровень + 1);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

//}

//} Данные отчета

Функция ПолучитьДанныеОтчетаТестирования(АдресОсновныхДанных, СписокОшибок, ТолькоОшибки = Ложь)
	
	ОшибкиТестирования = ПустаяТаблицаОшибокТестирования();
	ЗаполнитьОшибкиТестирования(СписокОшибок, ОшибкиТестирования);
	
	ВнешниеНаборы = ПолучитьИзВременногоХранилища(АдресОсновныхДанных);
	ВнешниеНаборы.Вставить("Ошибки", ОшибкиТестирования);
	
	СхемаКомпоновкиДанных = ПолучитьМакет("ДанныеОтчетаТестирования");
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	КомпоновщикНастроек.ЗагрузитьНастройки(СхемаКомпоновкиДанных.НастройкиПоУмолчанию);
	
	Если ТолькоОшибки Тогда
		
		Отбор = КомпоновщикНастроек.Настройки.Отбор.Элементы[0];
		Отбор.Использование = Истина;
		
	КонецЕсли;
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	Макет = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, КомпоновщикНастроек.ПолучитьНастройки(),,, Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(Макет, ВнешниеНаборы);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.УстановитьОбъект(Новый ДеревоЗначений);
	ДанныеОтчетаТестирования = ПроцессорВывода.Вывести(ПроцессорКомпоновки, Истина);
	
	Возврат ДанныеОтчетаТестирования;
	
КонецФункции

Функция ПодготовитьДанныеТестовОтчетаТестирования(ДеревоТестов, ИдентификаторФомы = Неопределено) Экспорт
	
	ТестовыеНаборы = ПустаяТаблицаТестовыхНаборов();
	ТестовыеМетоды = ПустаяТаблицаТестовыхМетодов();
	ИерархияТестовыхНаборов = ПустаяТаблицаИерархииТестовыхНаборов();
	
	ИсточникиДанныхОтчетаТестирования = Новый Структура;
	ИсточникиДанныхОтчетаТестирования.Вставить("ТестовыеНаборы", ТестовыеНаборы);
	ИсточникиДанныхОтчетаТестирования.Вставить("ТестовыеМетоды", ТестовыеМетоды);
	ИсточникиДанныхОтчетаТестирования.Вставить("ИерархияТестовыхНаборов", ИерархияТестовыхНаборов);
	
	Строки = ПодчиненныеСтроки(ДеревоТестов);
	
	ИтоговаяСтрока = ИерархияТестовыхНаборов.Добавить();
	ИтоговаяСтрока._GUID = Новый УникальныйИдентификатор;
	ИтоговаяСтрока.Имя = "Итого";
	КоличествоТестов = 0;
	Для Каждого Строка Из Строки Цикл
		КоличествоТестов = КоличествоТестов + Строка.КоличествоТестов;
	КонецЦикла;
	ИтоговаяСтрока.КоличествоТестов = КоличествоТестов;
	
	ЗаполнитьДанныеОтчетаРекурсивно(Строки, ИсточникиДанныхОтчетаТестирования);
	
	АдресДанных = ПоместитьВоВременноеХранилище(ИсточникиДанныхОтчетаТестирования, ИдентификаторФомы);
	Возврат АдресДанных;
	
КонецФункции

Процедура ЗаполнитьДанныеОтчетаРекурсивно(СтрокиДереваТестов, ИсточникиДанныхОтчетаТестирования)
	
	Порядок = 0;
	Для Каждого Строка Из СтрокиДереваТестов Цикл
		
		Порядок = Порядок + 1;
		Если Строка.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
			ТестовыйМетод = ИсточникиДанныхОтчетаТестирования.ТестовыеМетоды.Добавить();
			ЗаполнитьЗначенияСвойств(ТестовыйМетод, Строка);
			ТестовыйМетод.ИдентификаторТестовогоНабора = РодительскаяСтрока(Строка)._GUID;
			ТестовыйМетод.Порядок = Порядок;
		Иначе
			
			ЭлементИерархии = ИсточникиДанныхОтчетаТестирования.ИерархияТестовыхНаборов.Добавить();
			ЗаполнитьЗначенияСвойств(ЭлементИерархии, Строка);
			
			РодительскаяСтрока = РодительскаяСтрока(Строка);
			ГруппаТестовогоНабора = ?(РодительскаяСтрока = Неопределено, ИсточникиДанныхОтчетаТестирования.ИерархияТестовыхНаборов[0]._GUID, РодительскаяСтрока._GUID);
			ЭлементИерархии.ИдентификаторРодителя = ГруппаТестовогоНабора;
			ЭлементИерархии.Порядок = Порядок;
			
			Если Строка.ТипСтроки = мЗначенияТиповСтроки.ТестовыйСлучай Тогда
				
				ТестовыйНабор = ИсточникиДанныхОтчетаТестирования.ТестовыеНаборы.Добавить();
				ЗаполнитьЗначенияСвойств(ТестовыйНабор, ЭлементИерархии);
				
			КонецЕсли;
			
			ЗаполнитьДанныеОтчетаРекурсивно(ПодчиненныеСтроки(Строка), ИсточникиДанныхОтчетаТестирования)
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьОшибкиТестирования(СписокОшибок, ОшибкиТестирования)
	
	Для Каждого Элемент Из СписокОшибок Цикл
		Ошибка = Элемент.Значение;
		ОшибкаТестирования = ОшибкиТестирования.Добавить();
		ОшибкаТестирования.ИдентификаторТестовогоМетода = Ошибка.УИДСтрокиДерева;
		ОшибкаТестирования.Статус = Ошибка.Статус;
		ИнфоОшибки = Ошибка.ИнфоОшибки;
		Если Ошибка.Статус = СтатусыРезультатаТестирования.ТестПропущен Тогда
			ОшибкаТестирования.Пропущен = 1;
			ОшибкаТестирования.Описание = ИнфоОшибки.Описание;
		ИначеЕсли Ошибка.Статус = СтатусыРезультатаТестирования.ОшибкаПроверки Тогда
			ОшибкаТестирования.ОшибкаПроверки = 1;
			ОшибкаТестирования.Описание = ИнфоОшибки.Описание;
		Иначе
			ОписаниеОшибки = "";
			ОшибкаТестирования.НеизвестнаяОшибка = 1;
			Пока ИнфоОшибки <> Неопределено Цикл
				ОписаниеОшибки = ОписаниеОшибки
					+ ?(ПустаяСтрока(ОписаниеОшибки), "", Символы.ПС)
					+ ИнфоОшибки.ИмяМодуля + ", строка № "+ИнфоОшибки.НомерСтроки
					+ Символы.ПС
					+ ИнфоОшибки.ИсходнаяСтрока
					+ Символы.ПС
					+ ИнфоОшибки.Описание;
				
				ИнфоОшибки = ИнфоОшибки.Причина;
			КонецЦикла;
			ОшибкаТестирования.Описание = ОписаниеОшибки;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ПустаяТаблицаТестовыхНаборов()
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	ТипЧисло = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0, ДопустимыйЗнак.Неотрицательный));
	
	ТестовыеНаборы = Новый ТаблицаЗначений;
	ТестовыеНаборы.Колонки.Добавить("Имя", ТипСтрока);
	ТестовыеНаборы.Колонки.Добавить("ПолныйПуть", ТипСтрока);
	ТестовыеНаборы.Колонки.Добавить("_guid", ТипСтрока);
	ТестовыеНаборы.Колонки.Добавить("КоличествоТестов", ТипЧисло);
	ТестовыеНаборы.Колонки.Добавить("ТипСтроки", ТипЧисло);
	ТестовыеНаборы.Колонки.Добавить("Порядок", ТипЧисло);
	ТестовыеНаборы.Колонки.Добавить("ВремяВыполнения", ТипЧисло);
	
	Возврат ТестовыеНаборы;
	
КонецФункции

Функция ПустаяТаблицаТестовыхМетодов()
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	ТипБулево = Новый ОписаниеТипов("Булево");
	ТипЧисло = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0, ДопустимыйЗнак.Неотрицательный));
	
	ТестовыеМетоды = Новый ТаблицаЗначений;
	ТестовыеМетоды.Колонки.Добавить("Имя", ТипСтрока);
	ТестовыеМетоды.Колонки.Добавить("ЕстьПараметрыТеста", ТипБулево);
	ТестовыеМетоды.Колонки.Добавить("ПараметрыТеста", ТипСтрока);
	ТестовыеМетоды.Колонки.Добавить("_guid", ТипСтрока);
	ТестовыеМетоды.Колонки.Добавить("ИдентификаторТестовогоНабора", ТипСтрока);
	ТестовыеМетоды.Колонки.Добавить("ТипСтроки", ТипЧисло);
	ТестовыеМетоды.Колонки.Добавить("Порядок", ТипЧисло);
	ТестовыеМетоды.Колонки.Добавить("ВремяВыполнения", ТипЧисло);
	
	Возврат ТестовыеМетоды;
	
КонецФункции

Функция ПустаяТаблицаИерархииТестовыхНаборов()
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	ТипЧисло = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0, ДопустимыйЗнак.Неотрицательный));
	
	Иерархия = Новый ТаблицаЗначений;
	Иерархия.Колонки.Добавить("Имя", ТипСтрока);
	Иерархия.Колонки.Добавить("ПолныйПуть", ТипСтрока);
	Иерархия.Колонки.Добавить("_guid", ТипСтрока);
	Иерархия.Колонки.Добавить("КоличествоТестов", ТипЧисло);
	Иерархия.Колонки.Добавить("ИдентификаторРодителя", ТипСтрока);
	Иерархия.Колонки.Добавить("ТипСтроки", ТипЧисло);
	Иерархия.Колонки.Добавить("Порядок", ТипЧисло);
	Иерархия.Колонки.Добавить("ВремяВыполнения", ТипЧисло);
	
	Возврат Иерархия;
	
КонецФункции

Функция ПустаяТаблицаОшибокТестирования()
	
	ТипСтрока = Новый ОписаниеТипов("Строка");
	ТипЧисло = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(1, 0, ДопустимыйЗнак.Неотрицательный));
	
	ОшибкиТестирования = Новый ТаблицаЗначений;
	ОшибкиТестирования.Колонки.Добавить("Описание", ТипСтрока);
	ОшибкиТестирования.Колонки.Добавить("Пропущен", ТипЧисло);
	ОшибкиТестирования.Колонки.Добавить("ОшибкаПроверки", ТипЧисло);
	ОшибкиТестирования.Колонки.Добавить("НеизвестнаяОшибка", ТипЧисло);
	ОшибкиТестирования.Колонки.Добавить("ИдентификаторТестовогоМетода", ТипСтрока);
	ОшибкиТестирования.Колонки.Добавить("Статус", ТипСтрока);
	
	Возврат ОшибкиТестирования;
	
КонецФункции

//}

//{ ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ ОБЩЕГО НАЗНАЧЕНИЯ

// портирован из Functest
Функция СравнитьТаблицы(ТаблицаОжиданий, ТаблицаРезультатов, ТаблицаРазличий)
	
	Если ТаблицаОжиданий.Количество() <> ТаблицаРезультатов.Количество() Тогда
		Возврат РезультатыСравненияТаблиц.РазноеКоличествоСтрок;
	КонецЕсли;
	
	Если ТаблицаОжиданий.Количество() = 0 Тогда
		Возврат РезультатыСравненияТаблиц.ТаблицыСовпадают; //Пустые таблицы всегда одинаковы
	КонецЕсли;
	
	//Проверим структуру колонок
	
	//TODO При этом сравнении в структуре ТаблицаРезультатов может оказаться больше колонок, чем в ТаблицаОжиданий,
	// так что для абсолютного точного сравнения нужно добавить проверку совпадения количества колонок.
	ОжидаемыеКолонки = ТаблицаОжиданий.Колонки;
	КолонкиРезультата = ТаблицаРезультатов.Колонки;
	Для Каждого Колонка Из ОжидаемыеКолонки Цикл
		Если КолонкиРезультата.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат РезультатыСравненияТаблиц.РазличаютсяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СравнитьЗначенияТаблиц(ТаблицаОжиданий, ТаблицаРезультатов, ТаблицаРазличий);
	
КонецФункции

// портирован из Functest
Функция СравнитьЗначенияТаблиц(ТаблицаОжиданий, ТаблицаРезультатов, Различия)
	
	Различия = Новый ТаблицаЗначений;
	Различия.Колонки.Очистить();
	Различия.Колонки.Добавить("Строка",Новый ОписаниеТипов("Число"));
	Различия.Колонки.Добавить("Колонка",Новый ОписаниеТипов("Строка"));
	Различия.Колонки.Добавить("Ожидание");
	Различия.Колонки.Добавить("Результат");
	
	РезультатСравнения = РезультатыСравненияТаблиц.ТаблицыСовпадают;
	
	Колонки = ТаблицаОжиданий.Колонки;
	ГраницаСтрок = ТаблицаОжиданий.Количество() - 1;
	Для Индекс = 0 По ГраницаСтрок Цикл
		
		ОжидаемаяСтрока = ТаблицаОжиданий[Индекс];
		СтрокаРезультата = ТаблицаРезультатов[Индекс];
		
		Для Каждого Колонка Из Колонки Цикл
			ИмяКолонки = Колонка.Имя;
			
			ОжидаемоеЗначение = ОжидаемаяСтрока[ИмяКолонки];
			ЗначениеРезультата = СтрокаРезультата[ИмяКолонки];
			Если ОжидаемоеЗначение = ЗначениеРезультата
			 Или (Не ЗначениеЗаполнено(ОжидаемоеЗначение) И Не ЗначениеЗаполнено(ЗначениеРезультата)) Тогда //Пустые значения разных типов 1С-м не считаются равными :(
				Продолжить;
			КонецЕсли;
			
			Различие = Различия.Добавить();
			Различие.Строка = Индекс + 1;
			Различие.Колонка = ИмяКолонки;
			Различие.Ожидание = ОжидаемоеЗначение;
			Различие.Результат = ЗначениеРезультата;
			РезультатСравнения = РезультатыСравненияТаблиц.НеСовпадаютЗначенияВЯчейкеТаблицы;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат РезультатСравнения;
	
КонецФункции

Функция ИдентификаторПустогоКонтекста()
	Возврат "OF_xUnitFor1C_Empty";
КонецФункции

Функция ВывестиОшибку(Ошибка) Экспорт
	
	НужныйТекстОшибки = ПолучитьРазвернутыйТекстОшибки(Ошибка);
	
	ВывестиСообщение(НужныйТекстОшибки, СтатусСообщения.Важное);

	Возврат НужныйТекстОшибки;
КонецФункции

Функция ПолучитьРазвернутыйТекстОшибки(Ошибка)
	ТипОбъектаОшибка = ТипЗнч(Ошибка);
		
	Если ТипОбъектаОшибка = Тип("Структура") Тогда
		
		НужныйТекстОшибки = "[" + Ошибка.ИмяТестовогоНабора + ": " + Ошибка.ИмяТестовогоСлучая + "] " + Ошибка.Описание;
		
	ИначеЕсли ТипОбъектаОшибка = Тип("ИнформацияОбОшибке") Тогда
		
		НужныйТекстОшибки = Ошибка.Описание;
		
	Иначе
		
		НужныйТекстОшибки = Ошибка;
		
	КонецЕсли;
	Возврат НужныйТекстОшибки;
КонецФункции

Функция ФорматДСО(ДопСообщениеОшибки)
	Если ДопСообщениеОшибки = "" Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Символы.ПС + ДопСообщениеОшибки;
КонецФункции

Функция СоздатьОбъектВнешнейОбработкиОтключаяБезопасныйРежим(путьФайла) Экспорт
	Возврат ВнешниеОбработки.Создать(путьФайла, Ложь);
КонецФункции

Функция СоздатьОбъектОбработкиКонфигурации(ИмяОбработки) Экспорт
	Возврат Обработки[ИмяОбработки].Создать();
КонецФункции

Функция ОбновитьСостояниеВыбранныхСтрок(ВыбранныеСтроки) Экспорт
	
	СостояниеВыполнения = мЗначенияСостоянияТестов.НеВыполнялся;
	ВремяВыполнения = 0;
	Для Каждого Строка Из ВыбранныеСтроки Цикл
		
		Если Строка.ТипСтроки <> мЗначенияТиповСтроки.ТестовыйМетод Тогда
			Состояние = ОбновитьСостояниеВыбранныхСтрок(Строка.Строки);
			Строка.Состояние = Состояние.СостояниеВыполнения;
			Строка.ВремяВыполнения = Состояние.ВремяВыполнения;
		КонецЕсли;
		
		ЗапомнитьСамоеХудшееСостояние(СостояниеВыполнения, Строка.Состояние);
		ВремяВыполнения = ВремяВыполнения + Строка.ВремяВыполнения;
		
	КонецЦикла;
	
	Возврат Новый Структура("СостояниеВыполнения, ВремяВыполнения", СостояниеВыполнения, ВремяВыполнения);
	
КонецФункции

Процедура ОбновитьСостояниеРодителейВыбранныхСтрок(ВыбранныеСтроки) Экспорт
	
	Для Каждого Строка Из ВыбранныеСтроки Цикл
		ИзменитьСостояниеВыполненияРодителей(Строка);
		ИзменитьВремяВыполненияРодителей(Строка);
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает новое текущее состояние выполнения тестов
// в соответствии с приоритетами состояний:
// 		Красное - заменяет все другие состояния
// 		Желтое - заменяет только зеленое состояние
// 		Зеленое - заменяет только серое состояние (тест не выполнялся ни разу).
Функция ЗапомнитьСамоеХудшееСостояние(ТекущееСостояние, НовоеСостояние)
	
	ТекущееСостояние = Макс(ТекущееСостояние, НовоеСостояние);
	Возврат ТекущееСостояние;
	
КонецФункции

// Рекурсивно вверх от текущей строки меняет состояние у родительских строк.
// 
Процедура ИзменитьСостояниеВыполненияРодителей(СтрокаДереваТестов) Экспорт
	
	СтрокаРодителя = СтрокаДереваТестов.Родитель;
	Если СтрокаРодителя = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПредыдушееСостояние = СтрокаРодителя.Состояние;
	Состояние = мЗначенияСостоянияТестов.НеВыполнялся;
	Для Каждого Строка Из СтрокаРодителя.Строки Цикл
		Если Строка.Состояние = мЗначенияСостоянияТестов.НеВыполнялся Тогда
			Состояние = мЗначенияСостоянияТестов.НеВыполнялся;
			Прервать;
		КонецЕсли;
		ЗапомнитьСамоеХудшееСостояние(Состояние, Строка.Состояние);
	КонецЦикла;
	Если ПредыдушееСостояние <> Состояние Тогда
		СтрокаРодителя.Состояние = Состояние;
		ИзменитьСостояниеВыполненияРодителей(СтрокаРодителя);
	КонецЕсли;
	
КонецПроцедуры

Процедура ИзменитьВремяВыполненияРодителей(СтрокаДереваТестов) Экспорт
	
	СтрокаРодителя = СтрокаДереваТестов.Родитель;
	Если СтрокаРодителя = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ВремяВыполнения = 0;
	Для Каждого Строка Из СтрокаРодителя.Строки Цикл
		ВремяВыполнения = ВремяВыполнения + Строка.ВремяВыполнения;
	КонецЦикла;
	Если СтрокаРодителя.ВремяВыполнения <> ВремяВыполнения Тогда
		СтрокаРодителя.ВремяВыполнения = ВремяВыполнения;
		ИзменитьВремяВыполненияРодителей(СтрокаРодителя);
	КонецЕсли;
	
КонецПроцедуры

// Оповещает внешний мир о каком-либо событии. Используется
// для взаимодействия со скриптом Снегопата, а также с формой браузера 
// когда он запущен в режиме обычного приложения.
// 
Функция ОповеститьОСобытии(ИмяСобытия, Аргумент1=Неопределено)
	рез = Истина;
	Если mMiddleMan <> Неопределено Тогда
		Попытка
			Выполнить("mMiddleMan." + ИмяСобытия + "(Аргумент1);");			
		Исключение
			рез = Ложь;
		КонецПопытки;
	КонецЕсли;
	#Если Клиент Тогда 
		Оповестить("xUnitFor1C." + ИмяСобытия, Аргумент1);
	#КонецЕсли
	Возврат рез;
КонецФункции

Функция ЕстьОшибка_МетодОбъектаНеОбнаружен(текстОшибки, имяМетода)
	Результат = Ложь;
	Если Найти(текстОшибки, "Метод объекта не обнаружен ("+имяМетода+")") > 0 
		ИЛИ Найти(текстОшибки, "Object method not found ("+имяМетода+")") > 0  Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Процедура ЗаписатьКодВозвратаВЛогФайл(ПутьКФайлуЛога, КодВозврата, КодРезультатаТестирования = Неопределено) Экспорт
	ФайлЛога = Новый Файл(ПутьКФайлуЛога);
	КаталогЛога = Новый Файл(ФайлЛога.Путь);
	Если НЕ КаталогЛога.Существует() Тогда
		ВывестиСообщение("Ожидали, что каталог лог-файла кода возврата будет существовать, а он не существует. <"+ФайлЛога.Путь+">");
		Возврат;
	КонецЕсли;
	
	Запись = Новый ЗаписьТекста(ПутьКФайлуЛога);
	Запись.ЗаписатьСтроку(КодВозврата);
	Если КодРезультатаТестирования <> Неопределено Тогда
		Запись.ЗаписатьСтроку(КодРезультатаТестирования);
	КонецЕсли;
	Запись.Закрыть();
КонецПроцедуры

Процедура ЗарегистрироватьНачалоПрохожденияТеста(ИмяТестовогоСлучая, ПолныйПуть) Экспорт
	ЗаписьЖурналаРегистрации("xUnitFor1C.ЗапускТеста", 
    УровеньЖурналаРегистрации.Информация, , ,
    "Имя теста " + ИмяТестовогоСлучая+", путь теста "+ПолныйПуть);
КонецПроцедуры

Процедура ЗарегистрироватьОшибкуТеста(НужныйТекстОшибки, ИмяТестовогоСлучая, ПолныйПуть) Экспорт
	ЗаписьЖурналаРегистрации("xUnitFor1C.ПадениеТеста", 
		УровеньЖурналаРегистрации.Ошибка, , ,
		"Имя теста " + ИмяТестовогоСлучая+", путь теста "+ПолныйПуть+Символы.ПС+НужныйТекстОшибки);
КонецПроцедуры

Процедура УстановитьДанныеТекущегоТеста(ДанныеТекущегоТеста)
	
	УстановитьКонтекст(ДанныеТекущегоТеста, ИдентификаторКонтекстаДанныхТекущегоТеста());
	
КонецПроцедуры

Процедура УдалитьДанныеТекущегоТеста()
	
	УдалитьКонтекст(ИдентификаторКонтекстаДанныхТекущегоТеста());
	
КонецПроцедуры

Функция ПустыеДанныеТекущегоТеста()
	
	ДанныеТеста = Новый Структура;
	ДанныеТеста.Вставить("Имя", "");
	ДанныеТеста.Вставить("ПолныйПуть", "");
	ДанныеТеста.Вставить("СостояниеТеста", "");
	
	Возврат ДанныеТеста;
	
КонецФункции

Функция ИдентификаторКонтекстаДанныхТекущегоТеста()
	
	Возврат "xUnitFor1C_ДанныеТекущегоТеста";
	
КонецФункции

//}

//{ Обработка параметров командной строки
// Пример строки запуска для внешних файлов - "Тесты_Команда_Тестировать;E:\ТестыИМ\Тесты;ЗавершитьРаботуПослеТестирования"
//	"C:\Program Files (x86)\1cv82\8.2.18.96\bin\1cv8c.exe" /DisableStartupMessages /Execute E:\ТестыИМ\xddTestRunner.epf /S "server\ib" /Out "E:\ТестыИМ\Тесты\log.txt"  /C "Тесты_Команда_Тестировать;E:\ТестыИМ\Тесты;ЗавершитьРаботуПослеТестирования" /LogUI
//
// Пример строки запуска для внутренний тестов-обработок - "ЭтоТестИзКонфигурации;Тесты_Команда_Тестировать;Подсистемы.Тестирование;ЗавершитьРаботуПослеТестирования"
//	"C:\Program Files (x86)\1cv82\8.2.18.96\bin\1cv8c.exe" /DisableStartupMessages /Execute E:\ТестыИМ\xddTestRunner.epf /S "server\ib" /Out "E:\ТестыИМ\Тесты\log.txt"  /C "Тесты_Команда_Тестировать;E:\ТестыИМ\Тесты;ЗавершитьРаботуПослеТестирования" /LogUI
Функция РазобратьПараметрыЗапуска(СтрокаПараметровЗапуска) Экспорт
	
	РезСтруктураПараметров = СоздатьСтруктуруПараметровЗапуска();
	КоллекцияКомандЗапуска = СоздатьКоллекциюКомандЗапуска();
	
	путьКТестам = "";
	
	Если ПустаяСтрока(СтрокаПараметровЗапуска) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	параметрыЗапуска = ПолучитьМассивПараметровЗапуска(СтрокаПараметровЗапуска);
	
	МаксимальныйИндекс = параметрыЗапуска.ВГраница();
	
	Для Номер = 0 По МаксимальныйИндекс Цикл
		ЭлементМассива = параметрыЗапуска.Получить(Номер);
		
		лКомандаЗапуска = НРег(СокрЛП(ЭлементМассива));
		НомерМеньшеМаксимальногоИндекса = Номер < МаксимальныйИндекс;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.Выполнить, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда
			РезСтруктураПараметров.Выполнить = Истина;
			
			Номер=Номер+1;
			путьКТестам = СокрЛП(ПараметрыЗапуска[Номер]); 
			РезСтруктураПараметров.Загрузить = Истина;
			Продолжить;
			
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.Загрузить, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда 
			РезСтруктураПараметров.Загрузить = Истина;
			
			Номер=Номер+1;
			путьКТестам = СокрЛП(ПараметрыЗапуска[Номер]);
			Продолжить;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ОстановитьСистему, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.ОстановитьСистему = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ПутьОтчета, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда
			Номер=Номер+1;
			РезСтруктураПараметров.ПутьОтчета = СокрЛП(ПараметрыЗапуска[Номер]);
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ФорматОтчета, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда
			Номер=Номер+1;
			РезСтруктураПараметров.ФорматОтчета = СокрЛП(ПараметрыЗапуска[Номер]);
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ПутьКодаВозврата, лКомандаЗапуска) И НомерМеньшеМаксимальногоИндекса Тогда
			Номер=Номер+1;
			РезСтруктураПараметров.ПутьКодаВозврата = СокрЛП(ПараметрыЗапуска[Номер]);
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ВстроенныеТесты, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.ВстроенныеТесты = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.РегистрацияПрохожденияТестовВЖР, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.РегистрацияПрохожденияТестовВЖР = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.РегистрацияОшибокТестовВЖР, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.РегистрацияОшибокТестовВЖР = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.ВыводЛогаВФорматеTeamCity, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.ВыводЛогаВФорматеTeamCity = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.РежимОтладки, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.РежимОтладки = Истина;
		КонецЕсли;
		
		Если НайтиКоманду(КоллекцияКомандЗапуска.СлучайныйПорядокВыполнения, лКомандаЗапуска) Тогда
			РезСтруктураПараметров.СлучайныйПорядокВыполнения = Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не РезСтруктураПараметров.Загрузить Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Найти(ВРег(путьКТестам), "МЕТАДАННЫЕ.") = 1 Тогда
		РезСтруктураПараметров.ВстроенныеТесты = Истина;
	КонецЕсли;
	
	РезСтруктураПараметров.ПутьТестов = путьКТестам;
	
	ЗаполнитьЗначенияСвойств(ЭтотОбъект, РезСтруктураПараметров);
	
	Возврат РезСтруктураПараметров;
КонецФункции

Функция ПолучитьМассивПараметровЗапуска(СтрокаПараметровЗапуска)

	Если ПустаяСтрока(СтрокаПараметровЗапуска) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Параметр может состоять из частей, разделенных символом ";".
	// Первая часть - главное значение параметра запуска. 
	// Наличие дополнительных частей определяется логикой обработки главного параметра.
	ПараметрыЗапуска = РазложитьСтрокуВМассивПодстрок(СтрокаПараметровЗапуска, ";");
	
	Возврат ПараметрыЗапуска;
	
КонецФункции

// Разбивает строку на несколько строк по разделителю. Разделитель может иметь любую длину.
// Общий модуль СтроковыеФункцииКлиентСервер.
//
// Параметры:
//  Строка                 - Строка - текст с разделителями;
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ;
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     - для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат.
//     - если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//
//
// Возвращаемое значение:
//  Массив - массив строк.
//
// Примеры:
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",") - возвратит массив из 5 элементов, три из которых  - пустые строки;
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина) - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок(" один   два  ", " ") - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок("") - возвратит пустой массив;
//  РазложитьСтрокуВМассивПодстрок("",,Ложь) - возвратит массив с одним элементом "" (пустой строкой);
//  РазложитьСтрокуВМассивПодстрок("", " ") - возвратит массив с одним элементом "" (пустой строкой);
//
//&НаКлиенте
Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

Функция СоздатьСтруктуруПараметровЗапуска()
	Рез = Новый Структура;
	Рез.Вставить("ПутьТестов", Ложь);
	Рез.Вставить("Выполнить", Ложь);
	Рез.Вставить("Загрузить", Ложь);
	Рез.Вставить("ОстановитьСистему", Ложь);
	Рез.Вставить("ВстроенныеТесты", Ложь);
	Рез.Вставить("ПутьОтчета", "");
	Рез.Вставить("ФорматОтчета", "");
	Рез.Вставить("ПутьКодаВозврата", "");
	Рез.Вставить("РегистрацияПрохожденияТестовВЖР", Ложь);
	Рез.Вставить("РегистрацияОшибокТестовВЖР", Ложь);
	Рез.Вставить("ВыводЛогаВФорматеTeamCity", Ложь);
	Рез.Вставить("РежимОтладки", Ложь);
	Рез.Вставить("СлучайныйПорядокВыполнения", Ложь);
	Возврат Рез;
КонецФункции

Функция СоздатьКоллекциюКомандЗапуска()
	Рез = СоздатьСтруктуруПараметровЗапуска();
	Рез.Вставить("Выполнить", Новый Структура("Р,А", "Тесты_Команда_Тестировать","xddRun"));
	Рез.Вставить("Загрузить", Новый Структура("Р,А", "Тесты_Команда_Загрузить","xddLoad"));
	Рез.Вставить("ОстановитьСистему", Новый Структура("Р,А", "ЗавершитьРаботуПослеТестирования","xddShutdown"));
	Рез.Вставить("ВстроенныеТесты", Новый Структура("Р,А", "ЭтоТестИзКонфигурации","xddConfig"));
	Рез.Вставить("ПутьОтчета", Новый Структура("Р,А", "Тесты_Команда_КаталогОтчетов","xddReportPath"));
	Рез.Вставить("ФорматОтчета", Новый Структура("Р,А", "Тесты_Команда_ФорматОтчета","xddReportFormat"));
	Рез.Вставить("ПутьКодаВозврата", Новый Структура("Р,А", "Тесты_Путь_КЛогам","xddExitCodePath"));
	Рез.Вставить("РегистрацияПрохожденияТестовВЖР", Новый Структура("Р,А", "Тесты_ЗаписьВЖР","xddWriteLogEvent"));
	Рез.Вставить("РегистрацияОшибокТестовВЖР", Новый Структура("Р,А", "Тесты_ЗаписьОшибокВЖР","xddWriteErrorIntoLogEvent"));
	Рез.Вставить("ВыводЛогаВФорматеTeamCity", Новый Структура("Р,А", "Тесты_ФорматСообщенийTeamCity","xddLogForTeamCity"));
	Рез.Вставить("РежимОтладки", Новый Структура("Р,А", "Тесты_РежимОтадки","xddDebugMode"));
	Рез.Вставить("СлучайныйПорядокВыполнения", Новый Структура("Р,А", "Тесты_СлучайныйПорядок","xddRandomOrder"));
	Возврат Рез;
КонецФункции

Функция НайтиКоманду(КоллекцияКоманды, КомандаЗапускаНРег)
	Для каждого КлючЗначение Из КоллекцияКоманды Цикл
		Если НРег(КлючЗначение.Значение) = КомандаЗапускаНРег Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции
//}

//{ Работа со встроенными в конфигурация тестами и подсистемами
Процедура ЗаполнитьДеревоПодсистем(ДеревоПодсистем, ОтборПоИмениТеста) Экспорт
	Для каждого МетаПодсистема из Метаданные.Подсистемы цикл
		ДобавитьПодсистемуВДерево(МетаПодсистема, ДеревоПодсистем, ЭтотОбъект, ОтборПоИмениТеста);
	КонецЦикла;
КонецПроцедуры

Функция ДобавитьПодсистемуВДерево(ТекМетаПодсистема, РодительскаяСтрока, ОбработкаОбъект, ОтборПоИмениТеста)
	СтрокаПодсистемы = ПодчиненныеСтроки(РодительскаяСтрока).Добавить();
	СтрокаПодсистемы.Имя = ТекМетаПодсистема.Имя;
	СтрокаПодсистемы.Путь = "Метаданные."+СтрЗаменить(ТекМетаПодсистема.ПолноеИмя(), "Подсистема.", "Подсистемы.");
	СтрокаПодсистемы.ТипСтроки = мЗначенияТиповСтроки.Подсистема;
	Для Каждого Подсистема из ТекМетаПодсистема.Подсистемы Цикл 
		ДобавитьПодсистемуВДерево(Подсистема,СтрокаПодсистемы, ОбработкаОбъект, ОтборПоИмениТеста);
	КонецЦикла;
	
	Для каждого ОбъектМетаданных из ТекМетаПодсистема.Состав цикл
		Если Найти(ОбъектМетаданных.ПолноеИмя(), "Обработка."+ОтборПоИмениТеста) = 1 Тогда
			СтрокаТеста = ПодчиненныеСтроки(СтрокаПодсистемы).Добавить();
			СтрокаТеста.Имя = ОбъектМетаданных.Имя;
			СтрокаТеста.Путь = "Метаданные."+СтрЗаменить(ОбъектМетаданных.ПолноеИмя(), "Обработка.", "Обработки.");
			СтрокаТеста.ТипСтроки = мЗначенияТиповСтроки.ТестовыйСлучай;
		КонецЕсли;
	КонецЦикла;
	
	Если ПодчиненныеСтроки(СтрокаПодсистемы).Количество() = 0 Тогда
		ПодчиненныеСтроки(РодительскаяСтрока).Удалить(СтрокаПодсистемы);
	КонецЕсли;
	
КонецФункции
//}

//{ Работа с ошибками загрузки https://github.com/xDrivenDevelopment/xUnitFor1C/issues/442
//	Реально данные из хранилища записываются во внешние файлы настроек только при штатном закрытии 1С. 
//	При нештатном падении 1С никакой записи не происходит, поэтому хранилищем пользоваться нельзя. 
//	В итоге требуется работа с внешним файлом.
//
Функция СохраненнаяНастройка_БылаОшибкаПриПредыдущейЗагрузке() Экспорт
	БылаОшибкаПриПредыдущейЗагрузкеСохр = ХранилищеОбщихНастроек.Загрузить("xUnitFor1C_БылаОшибкаПриПредыдущейЗагрузке");
	БылаОшибкаПриПредыдущейЗагрузке = ?(БылаОшибкаПриПредыдущейЗагрузкеСохр = Истина, Истина, Ложь);
	Возврат БылаОшибкаПриПредыдущейЗагрузке;
КонецФункции

Процедура УстановитьНастройку_БылаОшибкаПриПредыдущейЗагрузке(БылаОшибкаПриПредыдущейЗагрузке) Экспорт
	ХранилищеОбщихНастроек.Сохранить("xUnitFor1C_БылаОшибкаПриПредыдущейЗагрузке", , БылаОшибкаПриПредыдущейЗагрузке);
КонецПроцедуры

//}

Функция ПодчиненныеСтроки(СтрокаДерева, РезЭтоСтрокаДереваУФ = Ложь) Экспорт
	РезЭтоСтрокаДереваУФ = ЭтоСтрокаДереваУФ(СтрокаДерева);
    Если Не РезЭтоСтрокаДереваУФ Тогда
        Строки = СтрокаДерева.Строки;
    Иначе
        Строки = СтрокаДерева.ПолучитьЭлементы();
	КонецЕсли;
	Возврат Строки;
КонецФункции

Функция РодительскаяСтрока(СтрокаДерева, РезЭтоСтрокаДереваУФ = Ложь) Экспорт
	РезЭтоСтрокаДереваУФ = ЭтоСтрокаДереваУФ(СтрокаДерева);
    Если Не РезЭтоСтрокаДереваУФ Тогда
        Родитель = СтрокаДерева.Родитель;
    Иначе
        Родитель = СтрокаДерева.ПолучитьРодителя();
	КонецЕсли;
	Возврат Родитель;
КонецФункции

Функция ЭтоСтрокаДереваУФ(СтрокаДерева)
	Рез = Ложь;
    Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") ИЛИ ТипЗнч(СтрокаДерева) = Тип("ДеревоЗначений") Тогда
    ИначеЕсли ТипЗнч(СтрокаДерева) = Тип("ДанныеФормыЭлементДерева") ИЛИ ТипЗнч(СтрокаДерева) = Тип("ДанныеФормыДерево") Тогда
		Рез = Истина;
	КонецЕсли;
	Возврат Рез;
КонецФункции

Процедура УпорядочитьСтрокиДереваТестов(ДеревоИлиСтрока, ЕстьКолонкаДопПорядка = Ложь) Экспорт
	
	Если ТипЗнч(ДеревоИлиСтрока) = Тип("СтрокаДереваЗначений") Тогда
		Если ДеревоИлиСтрока.ТипСтроки = мЗначенияТиповСтроки.ТестовыйСлучай
		 Или ДеревоИлиСтрока.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ИмяКолонкиДопПорядка = "ОсновнойПорядокСтрок";
	Если Не ЕстьКолонкаДопПорядка Тогда
		
		Если ТипЗнч(ДеревоИлиСтрока) = Тип("СтрокаДереваЗначений") Тогда
			Дерево = ДеревоИлиСтрока.Владелец();
		Иначе
			Дерево = ДеревоИлиСтрока;
		КонецЕсли;
		Дерево.Колонки.Добавить(ИмяКолонкиДопПорядка, Новый ОписаниеТипов("Число"));
		
	КонецЕсли;
	
	Для Каждого Строка Из ДеревоИлиСтрока.Строки Цикл
		Если Строка.ТипСтроки = мЗначенияТиповСтроки.ТестовыйСлучай
		 Или Строка.ТипСтроки = мЗначенияТиповСтроки.ТестовыйМетод Тогда
			Строка[ИмяКолонкиДопПорядка] = 1;
		Иначе
			Строка[ИмяКолонкиДопПорядка] = 0;
		КонецЕсли;
	КонецЦикла;
	
	ДеревоИлиСтрока.Строки.Сортировать(ИмяКолонкиДопПорядка + ", Имя");
	Для Каждого Строка Из ДеревоИлиСтрока.Строки Цикл
		УпорядочитьСтрокиДереваТестов(Строка, Истина);
	КонецЦикла;
	
	Если Не ЕстьКолонкаДопПорядка Тогда
		Дерево.Колонки.Удалить(ИмяКолонкиДопПорядка);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает объект метаданных по переданному полному строковому пути
//
Функция ПолучитьОбъектМетаданныхПоПути(ПутьКОбъекту) Экспорт
	//ВыражениеПодсистема = "Метаданные."+СтрЗаменить(Путь, "Подсистема.", "Подсистемы.");
	ОбъектКонфигурации = Неопределено;
	Попытка
		Выполнить("ОбъектКонфигурации = "+ПутьКОбъекту);
	Исключение
	КонецПопытки;	
	Возврат ОбъектКонфигурации;
КонецФункции

Функция ЭтоВнешняяОбработка(ПарамОбъект = Неопределено) Экспорт
	Перем НужныйОбъект;
	НужныйОбъект = ПарамОбъект;
	Если НужныйОбъект = Неопределено Тогда
		НужныйОбъект = ЭтотОбъект;
	КонецЕсли;
	Рез = Метаданные.НайтиПоТипу(ТипЗнч(НужныйОбъект)) = Неопределено;
	Возврат Рез; 
КонецФункции

Процедура ПодключитьИнформатор() Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		
		мПытаемсяСоздатьИнформатор = Истина;
		Если ЗапретИспользованияИнформатора Тогда
			мПытаемсяСоздатьИнформатор = Ложь;
		КонецЕсли;

		Если мПытаемсяСоздатьИнформатор Тогда
			ПолучитьИнформатор();
		КонецЕсли; 
	#Иначе
		мПытаемсяСоздатьИнформатор = Ложь;
	#КонецЕсли
	
КонецПроцедуры

Процедура ЗарегистрироватьОшибкуЗапускаТестирования(ПолныйПуть, ОписаниеОшибки) Экспорт
	ЗаписьЖурналаРегистрации("xUnitFor1C.ТестированиеНеВыполнено", 
    УровеньЖурналаРегистрации.Информация, , ,
    ОписаниеОшибки+", путь "+ПолныйПуть);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ  СОБЫТИЙ ОБЪЕКТА

////////////////////////////////////////////////////////////////////////////////
// ОПЕРАТОРЫ ОСНОВНОЙ ПРОГРАММЫ

//{ Состояния тестов - ВАЖЕН порядок заполнения в мЗначенияСостоянияТестов, используется в ЗапомнитьСамоеХудшееСостояние
мЗначенияСостоянияТестов = Новый Структура;
мЗначенияСостоянияТестов.Вставить("НеВыполнялся", 0);
мЗначенияСостоянияТестов.Вставить("Прошел"		, 1);
мЗначенияСостоянияТестов.Вставить("НеРеализован", 2);
мЗначенияСостоянияТестов.Вставить("Сломался"	, 3);
мЗначенияСостоянияТестов = Новый ФиксированнаяСтруктура(мЗначенияСостоянияТестов);
//} Состояния тестов

//{ Типы строк дерева тестов
мЗначенияТиповСтроки = Новый Структура;
мЗначенияТиповСтроки.Вставить("КаталогТестов", 0);
мЗначенияТиповСтроки.Вставить("ТестовыйСлучай", 1);
мЗначенияТиповСтроки.Вставить("ТестовыйМетод", 2);
мЗначенияТиповСтроки.Вставить("Подсистема", 3);
мЗначенияТиповСтроки.Вставить("Ошибка", 9);
мЗначенияТиповСтроки = Новый ФиксированнаяСтруктура(мЗначенияТиповСтроки);
//} Типы строк дерева тестов

мЗначениеМодульИлиФорма = Новый Структура();
мЗначениеМодульИлиФорма.Вставить("Модуль", 1);
мЗначениеМодульИлиФорма.Вставить("Форма", 2);
мЗначениеМодульИлиФорма = Новый ФиксированнаяСтруктура(мЗначениеМодульИлиФорма);

//{ Соответствие Статуса сообщения 1с Статусу в Buildlog TeamCity
мСоответствиеСтатусовДляTeamCity = Новый Соответствие;
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.БезСтатуса,"NORMAL");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.Обычное,"NORMAL");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.Информация,"NORMAL");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.Внимание,"WARNING");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.Важное,"FAILURE");
мСоответствиеСтатусовДляTeamCity.Вставить(СтатусСообщения.ОченьВажное,"ERROR");
мСоответствиеСтатусовДляTeamCity = Новый ФиксированноеСоответствие(мСоответствиеСтатусовДляTeamCity);
//} Соответствие Статуса сообщения 1с Статусу в Buildlog TeamCity

ТипСтрока = Новый ОписаниеТипов("Строка");
ТипЧисло = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0, ДопустимыйЗнак.Неотрицательный));
ТипБулево = Новый ОписаниеТипов("Булево");

//{ Инициализация дерева тестов
ДеревоТестов.Колонки.Добавить("Имя", ТипСтрока);
ДеревоТестов.Колонки.Добавить("ВремяВыполнения", ТипЧисло);
ДеревоТестов.Колонки.Добавить("ПолныйПуть", ТипСтрока);
ДеревоТестов.Колонки.Добавить("ТипСтроки", ТипЧисло);
ДеревоТестов.Колонки.Добавить("Состояние", ТипЧисло);
ДеревоТестов.Колонки.Добавить("ТестовыйСлучайОбъектМетаданныхИмя", ТипСтрока);
ДеревоТестов.Колонки.Добавить("_guid", ТипСтрока);
ДеревоТестов.Колонки.Добавить("МодульИлиФорма", ТипЧисло);
ДеревоТестов.Колонки.Добавить("ПараметрыТеста");
ДеревоТестов.Колонки.Добавить("ЕстьПараметрыТеста", ТипБулево);
ДеревоТестов.Колонки.Добавить("ИмяТестовогоСлучая", ТипСтрока);
ДеревоТестов.Колонки.Добавить("ПредставлениеПути", ТипСтрока);
ДеревоТестов.Колонки.Добавить("ИмяОсновнойУправляемойФормы", ТипСтрока);
ДеревоТестов.Колонки.Добавить("КоличествоТестов", ТипЧисло);
ДеревоТестов.Колонки.Добавить("ЭтоВнутренняяОбработка", ТипБулево);
ДеревоТестов.Колонки.Добавить("РазрешенСлучайныйПорядокВыполнения", ТипБулево);
ДеревоТестов.Колонки.Добавить("ИмяТестовогоНабора", ТипСтрока);
ДеревоТестов.Колонки.Добавить("СписокОшибок", Новый ОписаниеТипов("СписокЗначений"));
//} Инициализация дерева тестов

РезультатыСравненияТаблиц = Новый Структура;
РезультатыСравненияТаблиц.Вставить("ТаблицыСовпадают", 0);
РезультатыСравненияТаблиц.Вставить("НеСовпадаютЗначенияВЯчейкеТаблицы", 1);
РезультатыСравненияТаблиц.Вставить("РазноеКоличествоСтрок", 2);
РезультатыСравненияТаблиц.Вставить("РазличаютсяКолонки", 3);
РезультатыСравненияТаблиц = Новый ФиксированнаяСтруктура(РезультатыСравненияТаблиц);

мИнформатор = Неопределено;

мКоличествоТестовыхСлучаев  = 0;

ЭтоВстроеннаяОбработка = Не Метаданные.НайтиПоТипу(ТипЗнч(ЭтотОбъект)) = Неопределено;

СтатусыРезультатаТестирования = Новый Структура;
СтатусыРезультатаТестирования.Вставить("ОшибкаПроверки", "Failed");
СтатусыРезультатаТестирования.Вставить("НеизвестнаяОшибка", "Broken");
СтатусыРезультатаТестирования.Вставить("ТестПропущен", "Pending");
СтатусыРезультатаТестирования = Новый ФиксированнаяСтруктура(СтатусыРезультатаТестирования);

кэшТестовыхОбработок = Новый Соответствие;
